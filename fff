/*
 * Bootloader_raw.c
 * MODUL: RAW HEX YUKLEME (POLLING)
 * DIKKAT: Tera Term'de "Transmit delay -> msec/line: 50" AYARI SARTTIR!
 */

#include "Bootloader_raw.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

/* --- RENK KODLARI --- */
#define CLR_RESET   "\033[0m"
#define CLR_CYAN    "\033[1;96m"
#define CLR_GREEN   "\033[1;92m"
#define CLR_RED     "\033[1;91m"
#define CLR_YELLOW  "\033[1;93m"

/* Parsing Değişkenleri */
static uint32_t hex_upper_addr_raw = 0;

/* Slot Fonksiyonları (Diğer dosyadan) */
extern void Set_Active_Slot(uint32_t new_slot_flag);
extern uint32_t Get_Active_Slot_Addr(void);

/* ============================================================ */
/* YARDIMCI FONKSİYONLAR                                        */
/* ============================================================ */

static uint8_t Raw_HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t Raw_ParseByte(char* ptr) {
    return (Raw_HexCharToByte(ptr[0]) << 4) | Raw_HexCharToByte(ptr[1]);
}

/* Menü Seçimi İçin Satır Okuma */
static void Raw_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') { printf("\r\n"); buffer[index] = 0; return; }
            if (index < max_len - 1) {
                buffer[index++] = rx_char;
                HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
            }
        }
    }
}

/* Flash'a Yazma Yardımcısı (Hizalama İçin) */
/* Bu fonksiyon veriyi direkt Flash'a yazar, BUFFERLAMA YOKTUR */
static uint8_t Direct_Hex_Write(uint32_t addr, uint8_t byte)
{
    static uint8_t  align_buff[16];
    static uint32_t align_base = 0xFFFFFFFF;
    static uint8_t  align_idx = 0;
    
    uint32_t current_base = addr & 0xFFFFFFF0;
    uint8_t  offset = addr & 0x0F;

    /* Yeni bir 16'lık bloğa geçtik mi? */
    if (current_base != align_base) 
    {
        /* Öncekini Yaz (Eğer doluysa) */
        if (align_base != 0xFFFFFFFF && align_idx > 0) {
            if (Bootloader_Flash_Write(align_base, align_buff, 16) == 0) return 0;
        }
        
        /* Yeni Blok Hazırla */
        memset(align_buff, 0xFF, 16);
        align_base = current_base;
        align_idx = 0;
    }

    align_buff[offset] = byte;
    align_idx++;
    
    /* Eğer buffer dolduysa veya kritik bir yerdeysek yazmayı Flush fonksiyonuna bırakıyoruz.
       Ancak polling modunda her satırda yazmak güvenlidir. 
       Burada sadece biriktiriyoruz, satır sonunda Flush çağıracağız. */
    
    return 1;
}

static void Flush_Direct_Write(void)
{
    /* Tamponda kalan son veriyi yaz */
    /* Bootloader_Flash_Write fonksiyonu statik buffer kullanıyor, o yüzden güvenli */
    static uint8_t  align_buff[16]; // Bu fonksiyon için dummy (yukarıdaki statik değişkene erişemediğimiz için)
    /* Not: Yukarıdaki Direct_Hex_Write içindeki static değişkenler local static. 
       Onlara buradan erişemeyiz. O yüzden mantığı basitleştirip
       Tek bir flush fonksiyonu yazmak yerine, her satır sonunda yazmayı zorlayamayız.
       
       DÜZELTME: Basitlik için static değişkenleri global yapıyorum.
    */
    return; // Aşağıda global yaptık
}

/* --- GLOBAL YAPILAN BUFFER DEĞİŞKENLERİ (Dosya İçi) --- */
static uint8_t  g_align_buff[16];
static uint32_t g_align_base = 0xFFFFFFFF;
static uint8_t  g_align_dirty = 0;

static uint8_t Write_Byte_Global(uint32_t addr, uint8_t byte)
{
    uint32_t current_base = addr & 0xFFFFFFF0;
    uint8_t  offset = addr & 0x0F;

    if (current_base != g_align_base) 
    {
        /* Öncekini Yaz */
        if (g_align_dirty && g_align_base != 0xFFFFFFFF) {
            if (Bootloader_Flash_Write(g_align_base, g_align_buff, 16) == 0) return 0;
        }
        
        /* Yeni Blok */
        memset(g_align_buff, 0xFF, 16);
        g_align_base = current_base;
        g_align_dirty = 0;
    }

    g_align_buff[offset] = byte;
    g_align_dirty = 1;
    return 1;
}

static void Flush_Global(void)
{
    if (g_align_dirty && g_align_base != 0xFFFFFFFF) {
        if (Bootloader_Flash_Write(g_align_base, g_align_buff, 16) == 0)
            printf("\r\n[HATA] Yazma Basarisiz!\r\n");
        g_align_dirty = 0;
    }
}


/* ============================================================ */
/* ANA FONKSIYON: RECEIVE RAW HEX FILE (POLLING)                */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    char line_buffer[512];
    uint16_t line_idx = 0;
    uint8_t rx_char;
    
    uint32_t last_rx_time = 0;
    uint8_t file_started = 0;
    
    uint32_t current_addr = 0; 
    uint32_t target_slot = 0;
    uint32_t line_count = 0;
    
    char sub_cmd[10];

    /* Temizlik */
    hex_upper_addr_raw = 0;
    g_align_base = 0xFFFFFFFF; g_align_dirty = 0; memset(g_align_buff, 0xFF, 16);

    /* 1. HEDEF SEÇİMİ */
    printf("\r\n" CLR_CYAN "[RAW MODU]" CLR_RESET " Slot Secimi (a/b) > ");
    fflush(stdout);
    Raw_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        printf("HEDEF: SLOT A\r\n");
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        printf("HEDEF: SLOT B\r\n");
    }
    else { 
        printf("\r\nIptal.\r\n"); return; 
    }

    /* 2. SİLME İŞLEMİ (Baştan yapıyoruz ki arada takılmasın) */
    printf("Flash Siliniyor... Lutfen Bekleyin.\r\n");
    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
        printf(CLR_RED "[HATA] Silme Basarisiz!\r\n" CLR_RESET);
        return;
    }
    printf("[OK] Silindi.\r\n");

    printf(CLR_YELLOW "LUTFEN DIKKAT: Tera Term 'Transmit delay' ayarini 50ms yapin!\r\n" CLR_RESET);
    printf("Hazir. Dosyayi surukleyin...\r\n");

    last_rx_time = HAL_GetTick();

    /* 3. DÖNGÜ (Polling) */
    while(1)
    {
        /* 1 Karakter Oku (Timeout 1sn) */
        /* Veri akışı kesilirse (dosya biterse) timeout'a düşer */
        if (HAL_UART_Receive(&huart3, &rx_char, 1, 1000) == HAL_OK) 
        {
            last_rx_time = HAL_GetTick();
            file_started = 1;

            /* Satır Sonu Kontrolü */
            if (rx_char == '\n' || rx_char == '\r') 
            {
                if (line_idx > 0) {
                    line_buffer[line_idx] = '\0';
                    
                    /* --- HEX PARSING --- */
                    if (line_buffer[0] == ':') {
                        uint8_t count = Raw_ParseByte(&line_buffer[1]);
                        uint16_t alow = (Raw_ParseByte(&line_buffer[3])<<8)|Raw_ParseByte(&line_buffer[5]);
                        uint8_t type  = Raw_ParseByte(&line_buffer[7]);
                        
                        /* DATA KAYDI (00) */
                        if (type == 0x00) { 
                            current_addr = (hex_upper_addr_raw << 16) | alow;
                            
                            /* Filtre: Sadece hedef slot aralığını yaz */
                            if ( (target_slot == SLOT_A_ADDR && current_addr >= 0x08010000 && current_addr < 0x08200000) ||
                                 (target_slot == SLOT_B_ADDR && current_addr >= 0x08200000) )
                            {
                                for(int k=0; k<count; k++) {
                                    Write_Byte_Global(current_addr + k, Raw_ParseByte(&line_buffer[9+(k*2)]));
                                }
                            }
                            
                            /* Görsel Bildirim */
                            line_count++;
                            if(line_count % 20 == 0) { HAL_UART_Transmit(&huart3, (uint8_t*)".", 1, 10); }
                        }
                        /* EOF (01) */
                        else if (type == 0x01) { 
                            Flush_Global(); 
                            goto FINISH_RAW; 
                        }
                        /* EXT ADDR (04) */
                        else if (type == 0x04) { 
                            hex_upper_addr_raw = (Raw_ParseByte(&line_buffer[9])<<8)|Raw_ParseByte(&line_buffer[11]);
                        }
                    }
                    line_idx = 0;
                }
            } 
            else {
                if(line_idx < 511) line_buffer[line_idx++] = rx_char;
            }
        }
        else {
            /* Timeout: Dosya başladıysa ve 2 sn veri yoksa Bitti say */
            if (file_started && (HAL_GetTick() - last_rx_time > 2000)) {
                printf("\r\n[TIMEOUT] Veri bitti.\r\n");
                goto FINISH_RAW;
            }
        }
    }

FINISH_RAW:
    Flush_Global(); // Kalanları yaz
    
    if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
    else Set_Active_Slot(SLOT_A_ACTIVE);

    printf("\r\n\n" CLR_GREEN "[OK] RAW Yukleme Tamamlandi! Resetleniyor..." CLR_RESET "\r\n");
    HAL_Delay(1000);
    HAL_NVIC_SystemReset();
}
