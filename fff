/* ... (Önceki include ve define tanımları aynen kalacak) ... */

/* ============================================================ */
/* FONKSIYON 2: RAW HEX YUKLEME (Ring Buffer / Sürükle-Bırak)   */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    uint8_t rx_char;
    uint32_t last_rx_time = 0;
    uint8_t file_started = 0;
    uint32_t target_slot = 0;
    char sub_cmd[10];

    // Parsing değişkenleri
    char line_buffer[512];
    uint16_t line_idx = 0;
    uint32_t current_addr = 0;
    
    // İstatistikler
    uint32_t written_byte_count = 0;
    uint32_t skipped_byte_count = 0;

    /* --- Temizlik --- */
    g_ram_idx = 0;
    hex_upper_addr = 0; // Varsayılan 0. Eğer Hex dosyasında 04 kaydı yoksa 0 kabul edilir.
    smart_base_addr = 0xFFFFFFFF;
    smart_dirty = 0;
    memset(smart_buffer, 0xFF, 16);
    rb_head = 0; rb_tail = 0;

    /* --- ADIM 1: HEDEF SEÇİMİ --- */
    printf("\r\n" CLR_CYAN "[PLAN B: RAM BUFFER]" CLR_RESET " Slot Secimi (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) target_slot = SLOT_A_ADDR;
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) target_slot = SLOT_B_ADDR;
    else { printf("\r\nIptal.\r\n"); return; }

    /* --- ADIM 2: SADECE VERİ TOPLAMA --- */
    printf("\r\nDosyayi simdi surukleyin... (RAM'e kaydediliyor)\r\n");

    // UART Hata Bayraklarını Temizle ve Interrupt Başlat
    __HAL_UART_CLEAR_OREFLAG(&huart3); 
    HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    last_rx_time = HAL_GetTick();

    while(1)
    {
        // Ring Buffer'dan oku
        if (Ring_Buffer_Read(&rx_char) == 0)
        {
            last_rx_time = HAL_GetTick();

            // Dosya başlangıcı ':' karakteri ile yakalanır
            if (!file_started) {
                if (rx_char == ':') {
                    file_started = 1;
                    printf("[Start] Veri yakalandi...\r\n");
                }
            }

            if (file_started) {
                if (g_ram_idx < RAM_FILE_BUFFER_SIZE) {
                    g_ram_buffer[g_ram_idx++] = rx_char;
                } else {
                    printf("\r\n" CLR_RED "[HATA] RAM Buffer Doldu! (Max: %d bytes)" CLR_RESET "\r\n", RAM_FILE_BUFFER_SIZE);
                    goto EXIT_BUFFERED;
                }
            }
        }
        else
        {
            // Timeout kontrolü (1.5 sn veri gelmezse bitti kabul et)
            if (file_started && (HAL_GetTick() - last_rx_time > 1500)) {
                printf("\r\n[INFO] Transfer bitti. RAM Kullanim: %lu bytes.\r\n", g_ram_idx);
                break; 
            }
        }
    }

    if (g_ram_idx == 0) {
        printf("\r\n[HATA] Hic veri gelmedi veya ':' karakteri bulunamadi.\r\n");
        goto EXIT_BUFFERED;
    }

    /* --- ADIM 3: FLASH'A YAZMA AŞAMASI --- */
    HAL_UART_AbortReceive(&huart3); // Interruptları sustur, yazmaya odaklan

    printf(CLR_RED "Hedef Slot Siliniyor... " CLR_RESET); fflush(stdout);
    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
        printf("[FAIL] Silme Hatasi!\r\n"); goto EXIT_BUFFERED;
    }
    printf("[OK]\r\nRAM -> Flash isleniyor...\r\n"); 

    /* RAM'deki veriyi satır satır işle */
    for (uint32_t i = 0; i < g_ram_idx; i++)
    {
        char c = g_ram_buffer[i];

        // Yeni satır başlangıcı (Intel Hex ':' ile başlar)
        if (c == ':') {
            line_idx = 0;
            line_buffer[line_idx++] = ':';
            continue;
        }

        // Satır sonu geldi mi? (\n veya \r)
        if (c == '\n' || c == '\r') {
            if (line_idx > 0) { // Dolu bir satırımız var
                line_buffer[line_idx] = '\0'; // String sonlandır

                // Satır parse et
                if (line_buffer[0] == ':') {
                    uint8_t count = ParseByte(&line_buffer[1]);
                    uint16_t alow = (ParseByte(&line_buffer[3]) << 8) | ParseByte(&line_buffer[5]);
                    uint8_t type  = ParseByte(&line_buffer[7]);

                    // TYPE 04: Extended Linear Address (Üst 16-bit Adres)
                    if (type == 0x04) {
                        hex_upper_addr = (ParseByte(&line_buffer[9]) << 8) | ParseByte(&line_buffer[11]);
                        printf(" > Ust Adres Guncellendi: 0x%04X....\r\n", hex_upper_addr);
                    }
                    // TYPE 00: Data Record
                    else if (type == 0x00) {
                        current_addr = (hex_upper_addr << 16) | alow;

                        // --- KRİTİK KONTROL ---
                        // Adresin geçerli bir Flash adresi olup olmadığını ve
                        // seçilen slota uygun olup olmadığını kontrol et.
                        if (current_addr >= 0x08000000) 
                        {
                            // Slot kontrolü (Opsiyonel: Eğer slot dışına yazmaya çalışıyorsa uyar)
                            uint8_t range_check = Check_Hex_Address_Range(current_addr, target_slot);
                            
                            if (range_check == 1 || range_check == 2) { 
                                // 1: Hedef Slot, 2: Shared/Common alan (izin veriliyorsa)
                                for(int k=0; k<count; k++) {
                                    Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                                }
                                written_byte_count += count;
                            } else {
                                skipped_byte_count += count;
                                // İlk hatada uyar, spam yapma
                                if (skipped_byte_count < 20) {
                                    printf("[UYARI] Adres Slot Disi: 0x%08lX (Hedef: %c)\r\n", current_addr, (target_slot == SLOT_A_ADDR ? 'A' : 'B'));
                                }
                            }
                        } else {
                            // 0x08000000 altı adresler (genelde hata veya RAM adresi)
                            printf("[HATA] Gecersiz Adres: 0x%08lX\r\n", current_addr);
                        }
                    }
                    // TYPE 01: EOF
                    else if (type == 0x01) {
                        // Dosya sonu
                    }
                }
                line_idx = 0; // Bir sonraki satır için sıfırla
            }
        } 
        else {
            // Normal karakterleri buffera ekle
            if (line_idx < 511) line_buffer[line_idx++] = c;
        }
    }

    Flush_Smart_Buffer(); // Kalan son paketleri yaz

    printf("\r\n--------------------------------------\r\n");
    printf("Yazilan Byte: %lu\r\n", written_byte_count);
    printf("Atlanan Byte: %lu (Yanlis Adres/Slot)\r\n", skipped_byte_count);
    
    if (written_byte_count == 0) {
        printf(CLR_RED "[HATA] Hicbir veri Flash'a yazilmadi! Adresleri kontrol et." CLR_RESET "\r\n");
        goto EXIT_BUFFERED;
    }

    // Başarılı ise aktif slotu ayarla ve reset at
    if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
    else Set_Active_Slot(SLOT_A_ACTIVE);

    printf(CLR_GREEN "\r\n[BASARILI] Sistem yeniden baslatiliyor..." CLR_RESET "\r\n");
    HAL_Delay(500);
    HAL_NVIC_SystemReset();
    return;

EXIT_BUFFERED:
    printf("\r\n[FAIL] Islem Basarisiz.\r\n");
    // Hata durumunda interruptları tekrar açma ihtiyacı olabilir, ama reset daha temiz.
}