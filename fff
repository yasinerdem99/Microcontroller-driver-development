/*
 * Bootloader_hex.c
 * ULTIMATE FIX: DMA + D-CACHE MANAGEMENT
 */

#include "Bootloader_hex.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h" 
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

#define SOH 0x01
#define EOT 0x04
#define ACK 0x06
#define NAK 0x15
#define CAN 0x18
#define CHAR_C 'C'

/* --- DMA BUFFER --- */
#define DMA_RX_BUFFER_SIZE  16384  // 16KB
/* D-Cache uyumluluğu için buffer'ı 32-byte hizalamak iyi olur (Opsiyonel) */
static uint8_t dma_rx_buffer[DMA_RX_BUFFER_SIZE] __attribute__((aligned(32)));
static uint32_t rb_tail = 0;

/* Değişkenler */
static uint32_t hex_upper_addr = 0;
static uint8_t  smart_buffer[16];       
static uint32_t smart_base_addr = 0xFFFFFFFF; 
static uint8_t  smart_dirty = 0;        

/* ============================================================ */
/* YARDIMCI FONKSİYONLAR                                        */
/* ============================================================ */

/* STM32U5 GPDMA Sayacını Okuma */
static uint32_t Get_DMA_Counter(void)
{
    /* U5 serisinde GPDMA kullanılıyorsa standart makro çalışmayabilir.
       Genellikle bu makro U5 HAL kütüphanesinde CBR1 registerını okur. */
    return __HAL_DMA_GET_COUNTER(huart3.hdmarx);
}

static int DMA_Read_Byte(uint8_t *byte)
{
    uint32_t dma_counter = Get_DMA_Counter();
    uint32_t rb_head = DMA_RX_BUFFER_SIZE - dma_counter;

    if (rb_tail == rb_head) {
        return -1; // Veri yok
    }

    /* Cache Koruması: Okumadan önce bu bölgeyi Cache'ten sil (Invalidate) */
    /* Tek tek yapmak yavaşlatabilir, o yüzden Ana Fonksiyonda Cache'i komple kapatacağız. */
    
    *byte = dma_rx_buffer[rb_tail];
    rb_tail = (rb_tail + 1) % DMA_RX_BUFFER_SIZE;

    return 0;
}

static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

static uint16_t Calc_CRC16_Hex(const uint8_t *data, uint16_t size) {
    uint16_t crc = 0;
    while (size--) {
        crc ^= (*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021; else crc = crc << 1;
        }
    }
    return crc;
}

static void Hex_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') { 
                printf("\r\n"); buffer[index] = 0; return; 
            }
            if (index < max_len - 1) {
                buffer[index++] = rx_char;
                HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
            }
        }
    }
}

static void Flush_Smart_Buffer(void) {
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF) {
        if (Bootloader_Flash_Write(smart_base_addr, smart_buffer, 16) == 0) 
            printf("\r\n[HATA] Yazma Basarisiz! Adr: 0x%08lX\r\n", smart_base_addr);
        smart_dirty = 0; 
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte) {
    uint32_t aligned_base = addr & 0xFFFFFFF0;
    uint8_t offset = addr & 0x0F;
    if (aligned_base != smart_base_addr) {
        Flush_Smart_Buffer(); 
        memset(smart_buffer, 0xFF, 16); 
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }
    smart_buffer[offset] = byte;
    smart_dirty = 1; 
}

static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot) {
    if (addr >= 0x08000000 && addr < 0x08010000) return 2;
    if (target_slot == SLOT_A_ADDR && addr >= 0x08010000 && addr < 0x08200000) return 1;
    if (target_slot == SLOT_B_ADDR && addr >= 0x08200000) return 1;
    return 0;
}

/* ============================================================ */
/* XMODEM FONKSİYONU                                            */
/* ============================================================ */
void Xmodem_Receive_Hex_File(void)
{
    /* XMODEM Kodun Burada Kalacak */
    /* ... */
}

/* ============================================================ */
/* RAW HEX YUKLEME (DMA + CACHE FIX)                            */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    char line_buffer[512]; 
    uint16_t line_idx = 0; 
    uint8_t rx_char;
    uint32_t last_rx_time = 0; 
    uint8_t file_started = 0;
    
    uint32_t current_addr = 0; 
    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0; 
    
    char sub_cmd[10];
    uint8_t success_flag = 0;

    /* Reset */
    hex_upper_addr = 0;
    smart_base_addr = 0xFFFFFFFF; smart_dirty = 0; memset(smart_buffer, 0xFF, 16);
    rb_tail = 0;

    /* --- HEDEF SEÇİMİ --- */
    printf("\r\n[RAW DMA] Slot Secimi (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) target_slot = SLOT_A_ADDR;
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) target_slot = SLOT_B_ADDR;
    else { printf("\r\nIptal.\r\n"); return; }

    /* --- KRİTİK ADIM: D-CACHE KAPAT --- */
    /* DMA RAM'e yazarken CPU'nun eski veriyi okumasını engeller. */
    /* Fonksiyon sonunda tekrar açacağız. */
    SCB_DisableDCache(); 
    printf("[SYS] D-Cache Gecici Olarak Kapatildi.\r\n");

    printf("\r\nHazir. Dosyayi surukleyin... (DMA Modu)\r\n");

    /* --- DMA BAŞLAT --- */
    if (HAL_UART_Receive_DMA(&huart3, dma_rx_buffer, DMA_RX_BUFFER_SIZE) != HAL_OK) {
        printf("\r\n[KRITIK HATA] DMA Baslatilamadi!\r\n");
        SCB_EnableDCache();
        return;
    }
    
    last_rx_time = HAL_GetTick();

    while(1)
    {
        /* DMA Havuzundan Veri Çek */
        if (DMA_Read_Byte(&rx_char) == 0) 
        {
            last_rx_time = HAL_GetTick();
            
            if (rx_char == ':') {
                file_started = 1;
                line_idx = 0;
                line_buffer[line_idx++] = ':';
                continue;
            }

            if ((rx_char == '\n' || rx_char == '\r') && line_idx > 0) 
            {
                line_buffer[line_idx] = '\0';
                
                if (line_buffer[0] == ':') {
                    uint8_t count = ParseByte(&line_buffer[1]);
                    uint16_t alow = (ParseByte(&line_buffer[3])<<8)|ParseByte(&line_buffer[5]);
                    uint8_t type  = ParseByte(&line_buffer[7]);
                    
                    if (type == 0x00) { // DATA
                        current_addr = (hex_upper_addr << 16) | alow;
                        if (current_addr < 0x08000000) { line_idx = 0; continue; }

                        if (is_flash_erased == 0) {
                            if (Check_Hex_Address_Range(current_addr, target_slot) != 1) {
                                printf("\r\n[HATA] Adres: 0x%08lX\r\n", current_addr); goto EXIT_TRANSFER; 
                            }
                            printf("[INFO] Siliniyor... "); fflush(stdout);
                            if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                printf("[FAIL]\r\n"); goto EXIT_TRANSFER;
                            }
                            printf("[OK] Yukleniyor\r\n"); fflush(stdout);
                            is_flash_erased = 1;
                        }
                        
                        for(int k=0; k<count; k++) {
                            Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                        }
                    }
                    else if (type == 0x01) { success_flag = 1; goto EXIT_TRANSFER; }
                    else if (type == 0x04) { hex_upper_addr = (ParseByte(&line_buffer[9])<<8)|ParseByte(&line_buffer[11]); }
                }
                line_idx = 0;
            } 
            else {
                if(line_idx < 511) line_buffer[line_idx++] = rx_char;
            }
        }
        else {
            /* Timeout: 3 sn */
            if (file_started && (HAL_GetTick() - last_rx_time > 3000)) {
                if(is_flash_erased) success_flag = 1;
                else {
                    /* DEBUG: DMA Durumunu Bas */
                    uint32_t cnt = Get_DMA_Counter();
                    uint32_t head = DMA_RX_BUFFER_SIZE - cnt;
                    printf("\r\n[TIMEOUT] DMA Head: %lu, Tail: %lu\r\n", head, rb_tail);
                }
                goto EXIT_TRANSFER;
            }
        }
    }

EXIT_TRANSFER:
    /* DMA DURDUR VE CACHE AÇ */
    HAL_UART_DMAStop(&huart3);
    SCB_EnableDCache();
    
    Flush_Smart_Buffer(); 
    
    if (success_flag) {
        if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
        else Set_Active_Slot(SLOT_A_ACTIVE);
        printf("\r\n\n[OK] RAW Yukleme Tamamlandi!\r\n");
    } else {
        printf("\r\n[FAIL] Yukleme tamamlanamadi!\r\n");
    }
}
