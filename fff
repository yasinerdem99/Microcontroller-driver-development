/*
 * Bootloader_hex.c
 * VERSION: XMODEM (Standart) + RAW (RAM Buffered / Drag-Drop Safe)
 */

#include "Bootloader_hex.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

#define SOH 0x01
#define EOT 0x04
#define ACK 0x06
#define NAK 0x15
#define CAN 0x18
#define CHAR_C 'C'

/* Renk Kodları */
#define CLR_RESET   "\033[0m"
#define CLR_CYAN    "\033[1;96m"
#define CLR_GREEN   "\033[1;92m"
#define CLR_RED     "\033[1;91m"
#define CLR_YELLOW  "\033[1;93m"

/* --- RAW MOD İÇİN RAM BUFFER AYARLARI --- */
/* Maksimum Uygulama Boyutu: 48 KB (Değiştirebilirsin) */
#define RAW_BUFFER_SIZE  48000
static uint8_t g_raw_buffer[RAW_BUFFER_SIZE];
static uint32_t g_max_offset = 0;

/* --- RING BUFFER (Giriş Havuzu) --- */
#define RING_BUFFER_SIZE  4096
static uint8_t  rb_data[RING_BUFFER_SIZE];
static volatile uint16_t rb_head = 0;
static volatile uint16_t rb_tail = 0;
static uint8_t  rx_byte_it;

/* Değişkenler */
static uint32_t hex_upper_addr = 0;
static uint8_t  smart_buffer[16];
static uint32_t smart_base_addr = 0xFFFFFFFF;
static uint8_t  smart_dirty = 0;

/* ============================================================ */
/* YARDIMCI FONKSİYONLAR                                        */
/* ============================================================ */

/* Kesme (Interrupt) */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        rb_data[rb_head++] = rx_byte_it;
        if (rb_head >= RING_BUFFER_SIZE) rb_head = 0;
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

/* Hata Kurtarma */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

/* Havuzdan Oku */
static int Ring_Buffer_Read(uint8_t *byte) {
    if (rb_head == rb_tail) return -1;
    *byte = rb_data[rb_tail++];
    if (rb_tail >= RING_BUFFER_SIZE) rb_tail = 0;
    return 0;
}

static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

static uint16_t Calc_CRC16_Hex(const uint8_t *data, uint16_t size) {
    uint16_t crc = 0;
    while (size--) {
        crc ^= (*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021; else crc = crc << 1;
        }
    }
    return crc;
}

static void Hex_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') { printf("\r\n"); buffer[index] = 0; return; }
            if (index < max_len - 1) {
                buffer[index++] = rx_char;
                HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
            }
        }
    }
}

static void Flush_Smart_Buffer(void) {
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF) {
        if (Bootloader_Flash_Write(smart_base_addr, smart_buffer, 16) == 0)
            printf("\r\n[HATA] Yazma Basarisiz!\r\n");
        smart_dirty = 0;
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte) {
    uint32_t aligned_base = addr & 0xFFFFFFF0;
    uint8_t offset = addr & 0x0F;
    if (aligned_base != smart_base_addr) {
        Flush_Smart_Buffer();
        memset(smart_buffer, 0xFF, 16);
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }
    smart_buffer[offset] = byte;
    smart_dirty = 1;
}

static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot) {
    if (addr >= 0x08000000 && addr < 0x08010000) return 2;
    if (target_slot == SLOT_A_ADDR && addr >= 0x08010000 && addr < 0x08200000) return 1;
    if (target_slot == SLOT_B_ADDR && addr >= 0x08200000) return 1;
    return 0;
}

/* ============================================================ */
/* FONKSIYON 1: XMODEM (Standard HEX)                           */
/* ============================================================ */
void Xmodem_Receive_Hex_File(void)
{
    uint8_t rx_buffer[133];
    uint8_t packet_number = 1;
    uint8_t status = 0;
    uint8_t xmodem_done = 0;
    uint8_t hex_parsing_done = 0;

    char line_buffer[128];
    uint8_t line_idx = 0, in_line = 0;

    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;

    char user_response[10];
    uint32_t total_bytes = 0;

    /* Değişkenleri Sıfırla */
    hex_upper_addr = 0;
    smart_base_addr = 0xFFFFFFFF; smart_dirty = 0; memset(smart_buffer, 0xFF, 16);

    /* --- 1. HEDEFİ OTOMATİK BELİRLE (PING-PONG) --- */
    extern uint32_t Get_Active_Slot_Addr(void);
    uint32_t current_active = Get_Active_Slot_Addr();

    printf("\r\n========================================\r\n");
    if (current_active == SLOT_A_ADDR) {
        target_slot = SLOT_B_ADDR;
        printf(" [INFO] Mevcut: SLOT A (Aktif)\r\n");
        printf(" [AUTO] HEDEF : SLOT B (0x%08lX)\r\n", target_slot);
    } else {
        target_slot = SLOT_A_ADDR;
        printf(" [INFO] Mevcut: SLOT B (Aktif)\r\n");
        printf(" [AUTO] HEDEF : SLOT A (0x%08lX)\r\n", target_slot);
    }
    printf("========================================\r\n");

    /* --- 2. ONAY AL --- */
    printf(CLR_YELLOW "Islemi onayliyor musunuz? (y/n) > " CLR_RESET);
    fflush(stdout);
    Hex_Read_Line(user_response, 10);

    if (user_response[0] != 'y' && user_response[0] != 'Y') {
        printf(CLR_RED "[IPTAL] Islem durduruldu.\r\n" CLR_RESET);
        return;
    }

    /* NOT: Burada silme yapmıyoruz! Dosya gelince adresine bakıp sileceğiz. */
    printf("\r\n[HAZIR] Lutfen .hex dosyasini gonderin...\r\n");

    /* --- 3. HANDSHAKE --- */
    uint32_t last_c = 0;
    uint8_t handshake = 0;
    while (!handshake) {
        if (HAL_GetTick() - last_c > 1000) {
            uint8_t c = CHAR_C; HAL_UART_Transmit(&huart3, &c, 1, 100); last_c = HAL_GetTick();
        }
        if (HAL_UART_Receive(&huart3, &status, 1, 10) == HAL_OK) {
            if (status == 'e' || status == 'E') { printf("\r\n[IPTAL]\r\n"); return; }
            if (status == SOH) handshake = 1;
        }
    }

    /* --- 4. PAKET DÖNGÜSÜ --- */
    while (!xmodem_done)
    {
        rx_buffer[0] = status;
        if (HAL_UART_Receive(&huart3, &rx_buffer[1], 132, 2000) != HAL_OK) {
            uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
            HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY); continue;
        }

        uint16_t rcrc = (rx_buffer[131] << 8) | rx_buffer[132];
        if (rcrc != Calc_CRC16_Hex(&rx_buffer[3], 128)) {
             uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
             HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY); continue;
        }

        total_bytes += 128;
        printf("\r[XMODEM] Paket: %3d | Bytes: %lu   ", packet_number, total_bytes); fflush(stdout);

        if (!hex_parsing_done)
        {
            for (int i = 0; i < 128; i++)
            {
                char c = rx_buffer[3 + i];
                if (c == 0x1A) continue;
                if (c == ':') { in_line = 1; line_idx = 0; continue; }

                if (in_line)
                {
                    if (c == '\r' || c == '\n') {
                        in_line = 0;
                        line_buffer[line_idx] = '\0';

                        uint8_t count = ParseByte(&line_buffer[0]);
                        uint16_t alow = (ParseByte(&line_buffer[2])<<8)|ParseByte(&line_buffer[4]);
                        uint8_t type  = ParseByte(&line_buffer[6]);

                        /* TYPE 04: Adres Güncelle (Önce bunu işle!) */
                        if (type == 0x04) {
                            hex_upper_addr = (ParseByte(&line_buffer[8])<<8)|ParseByte(&line_buffer[10]);
                        }

                        /* TYPE 00: Data */
                        else if (type == 0x00) {
                            uint32_t c_addr = (hex_upper_addr << 16) | alow;

                            /* FİLTRE: 0x08... olmayan adresleri yoksay (Gürültü koruması) */
                            if (c_addr < 0x08000000) continue;

                            /* --- GÜVENLİK VE SİLME MANTIĞI --- */
                            /* Henüz silinmediyse (ilk geçerli veri satırıysa) */
                            if (is_flash_erased == 0)
                            {
                                /* 1. Adresi Kontrol Et: Hedefe uyuyor mu? */
                                uint8_t check = Check_Hex_Address_Range(c_addr, target_slot);

                                if (check == 0 || check == 2) {
                                    // HATA! Adres Yanlış
                                    uint8_t can = CAN;
                                    for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 100);

                                    printf("\r\n\r\n" CLR_RED "[HATA] ADRES UYUSMAZLIGI!" CLR_RESET "\r\n");
                                    printf("Gelen Adres : 0x%08lX\r\n", c_addr);
                                    printf("Hedef Slot  : 0x%08lX\r\n", target_slot);
                                    printf("Islem iptal edildi. Flash'a dokunulmadi.\r\n");
                                    return;
                                }

                                /* 2. Adres Doğru -> Şimdi SİL */
                                printf("\r\n[INFO] Dosya Adresi Dogrulandi. Flash Siliniyor... "); fflush(stdout);
                                if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                    uint8_t can = CAN;
                                    for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 100);
                                    printf(CLR_RED "[FAIL] Silme Hatasi!\r\n" CLR_RESET);
                                    return;
                                }
                                printf(CLR_GREEN "[OK]" CLR_RESET "\r\nYukleniyor... ");
                                is_flash_erased = 1; // Bayrağı kaldır, artık sormadan yaz
                            }

                            /* Yazma İşlemi */
                            for(int k=0; k<count; k++)
                                Smart_Hex_Write_Byte(c_addr+k, ParseByte(&line_buffer[8+(k*2)]));
                        }
                        /* TYPE 01: EOF */
                        else if (type == 0x01) {
                            Flush_Smart_Buffer();
                            hex_parsing_done = 1;
                        }
                    }
                    else if (line_idx < 127) {
                        line_buffer[line_idx++] = c;
                    }
                }
            }
        }

        uint8_t ack = ACK; HAL_UART_Transmit(&huart3, &ack, 1, 100);
        packet_number++;
        HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY);

        if (status == EOT) {
            HAL_UART_Transmit(&huart3, &ack, 1, 100);
            Flush_Smart_Buffer();

            extern void Set_Active_Slot(uint32_t new_slot_flag);
            if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
            else Set_Active_Slot(SLOT_A_ACTIVE);

            xmodem_done = 1;
        }
    }

    printf("\r\n\n" CLR_GREEN "[OK] XMODEM Yukleme Tamamlandi! (Resetleniyor...)" CLR_RESET "\r\n");
    HAL_Delay(500);
    HAL_NVIC_SystemReset();
}
/* ============================================================ */
/* FONKSIYON 2: RAW HEX (RAM BUFFERED - POLLING MODE)           */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    uint8_t c;
    char line_buffer[600];
    uint16_t line_idx = 0;
    uint8_t in_line = 0;

    uint32_t target_slot_addr = 0;
    uint32_t target_slot = 0;
    char sub_cmd[10];

    /* Dinamik Adres Yakalama Değişkenleri */
    uint32_t detected_base_addr = 0xFFFFFFFF; // Dosyanın başlangıç adresi
    uint8_t base_addr_locked = 0;             // İlk adres kilitlendi mi?

    /* Temizlik */
    memset(g_raw_buffer, 0xFF, RAW_BUFFER_SIZE);
    g_max_offset = 0;
    hex_upper_addr = 0; // Varsayılan segment 0
    // rb_head = 0; rb_tail = 0; // Ring buffer kullanılmayacak

    /* 1. SLOT SEÇİMİ */
    printf("\r\n" CLR_CYAN "[RAW HEX - POLLING MODU]" CLR_RESET " Slot Sec (A/B) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        target_slot_addr = SLOT_A_ADDR;
        printf("HEDEF: SLOT A (Adres: 0x%08X)\r\n", (unsigned int)target_slot_addr);
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        target_slot_addr = SLOT_B_ADDR; // Örn: 0x08020000 veya 0x08040000
        printf("HEDEF: SLOT B (Adres: 0x%08X)\r\n", (unsigned int)target_slot_addr);
    }
    else {
        printf("\r\nIptal.\r\n"); return;
    }

    printf("\r\n" CLR_GREEN "[HAZIR] Lutfen dosya ICERIGINI yapistirin...\r\n" CLR_RESET);

    /* --- KRİTİK: INTERRUPT KAPATILIYOR --- */
    /* Polling modunda veriyi kaçırmamak için RX kesmesini geçici olarak kapatıyoruz */
    __HAL_UART_DISABLE_IT(&huart3, UART_IT_RXNE);

    /* Önceki hata bayraklarını temizle (Overrun vs.) */
    __HAL_UART_CLEAR_OREFLAG(&huart3);
    __HAL_UART_CLEAR_NEFLAG(&huart3);
    __HAL_UART_CLEAR_FEFLAG(&huart3);

    uint32_t last_rx = HAL_GetTick();
    uint8_t data_started = 0;
    uint32_t total_lines_ok = 0;

    /* 2. VERİ ALMA (Polling Loop) */
    while (1)
    {
        /* * POLLING OKUMA:
         * Her karakter için 10ms bekler. Hızlı yapıştırmada veri anında gelir, beklemez.
         * Veri akışı durduğunda (dosya bittiğinde) Timeout verir.
         */
        HAL_StatusTypeDef status = HAL_UART_Receive(&huart3, &c, 1, 10);

        if (status == HAL_OK)
        {
            last_rx = HAL_GetTick();

            /* Başlangıç Yakalama */
            if (!data_started && c == ':') data_started = 1;
            if (!data_started) continue;

            if (c == ':') {
                in_line = 1; line_idx = 0; continue;
            }
            if (!in_line) continue;

            /* Satır Sonu Geldiyse Parse Et */
            if (c == '\r' || c == '\n') {
                in_line = 0;
                line_buffer[line_idx] = '\0';

                /* Satır Çok Kısaysa Atla */
                if (line_idx < 10) continue;

                /* --- HEX PARSING --- */
                uint8_t count = ParseByte(&line_buffer[0]);
                uint16_t alow = (ParseByte(&line_buffer[2]) << 8) | ParseByte(&line_buffer[4]);
                uint8_t type  = ParseByte(&line_buffer[6]);

                /* --- CHECKSUM KONTROLU --- */
                uint8_t sum = count + (alow >> 8) + (alow & 0xFF) + type;
                for (int i = 0; i < count; i++) {
                    sum += ParseByte(&line_buffer[8 + i*2]);
                }
                uint8_t recv_checksum = ParseByte(&line_buffer[8 + count*2]);

                if ((uint8_t)(sum + recv_checksum) != 0) {
                    /* Checksum hatası varsa bu satırı yoksay */
                    line_idx = 0;
                    continue;
                }

                total_lines_ok++;

                /* Tip 04: Extended Linear Address */
                if (type == 0x04) {
                    hex_upper_addr = (ParseByte(&line_buffer[8]) << 8) | ParseByte(&line_buffer[10]);
                }
                /* Tip 00: Data Record */
                else if (type == 0x00) {
                    uint32_t abs_addr = (hex_upper_addr << 16) | alow;

                    /* --- RELOCATION LOGIC --- */
                    if (!base_addr_locked) {
                        detected_base_addr = abs_addr;
                        base_addr_locked = 1;
                    }

                    if (abs_addr >= detected_base_addr)
                    {
                        uint32_t offset = abs_addr - detected_base_addr;

                        if (offset + count < RAW_BUFFER_SIZE) {
                            for(int i=0; i<count; i++) {
                                g_raw_buffer[offset + i] = ParseByte(&line_buffer[8+(i*2)]);
                            }
                            if (offset + count > g_max_offset) g_max_offset = offset + count;
                        }
                    }
                }
                /* Tip 01: EOF */
                else if (type == 0x01) {
                    goto START_FLASHING;
                }

                line_idx = 0;
            } else {
                if (line_idx < 511) line_buffer[line_idx++] = c;
            }
        }
        else
        {
            /* Timeout Durumu (Veri gelmiyor) */
            /* Veri başladıysa ve 1 saniyedir yeni veri gelmiyorsa bitir */
            if (data_started && (HAL_GetTick() - last_rx > 1000)) {
                printf("\r\n[TIMEOUT] EOF gelmedi. Islem bitiriliyor...\r\n");
                goto START_FLASHING;
            }
        }
    }

START_FLASHING:
    /* Interrupt'ları geri açabiliriz veya Reset atılacağı için gerek yok */
    // __HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);

    /* GÜVENLİK KONTROLÜ */
    if (g_max_offset < 128) {
        printf("\r\n" CLR_RED "[HATA] Gecersiz veya cok kucuk veri (%lu bytes)!" CLR_RESET "\r\n", g_max_offset);
        printf("Muhtemelen dosya YOLUNU yapistirdiniz. Lutfen dosya ICERIGINI kopyalayip yapistirin.\r\n");
        printf("Flash silinmedi, sistem guvende.\r\n");
        printf("Sistem Resetleniyor...\r\n");
        HAL_Delay(2000);
        HAL_NVIC_SystemReset();
        return;
    }

    printf("\r\nDosya Alindi. Toplam Boyut: %lu bytes\r\n", g_max_offset);
    printf("Flash Siliniyor...\r\n");

    /* 3. FLASH SİLME */
    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
        printf("\r\n[HATA] Silme Basarisiz! (Flash kilidini kontrol et)\r\n");
        return;
    }

    printf("Flash Yaziliyor...\r\n");

    /* 4. RAM -> FLASH YAZMA */
    uint32_t write_addr = target_slot_addr;
    uint32_t bytes_written = 0;

    while (bytes_written < g_max_offset)
    {
        uint32_t chunk_len = 128;
        if (g_max_offset - bytes_written < 128) chunk_len = g_max_offset - bytes_written;

        if (Bootloader_Flash_Write(write_addr, &g_raw_buffer[bytes_written], chunk_len) == 0) {
            printf("\r\n[HATA] Yazma Hatasi! Adres: 0x%08X\r\n", (unsigned int)write_addr);
            return;
        }

        write_addr += chunk_len;
        bytes_written += chunk_len;

        if (bytes_written % 1024 == 0) { printf("."); fflush(stdout); }
    }

    /* 5. TAMAMLANDI */
    printf("\r\n" CLR_GREEN "[OK] Yazma Tamamlandi!" CLR_RESET "\r\n");

    if (target_slot == SLOT_A_ADDR) Set_Active_Slot(SLOT_A_ACTIVE);
    else Set_Active_Slot(SLOT_B_ACTIVE);

    /* --- GÖRSEL RESET GERİ SAYIMI --- */
    printf("Sistem Resetleniyor... (3)\r\n");
    HAL_Delay(1000);
    printf("Sistem Resetleniyor... (2)\r\n");
    HAL_Delay(1000);
    printf("Sistem Resetleniyor... (1)\r\n");
    HAL_Delay(1000);
    printf("Gule gule!\r\n");

    HAL_NVIC_SystemReset();
}
