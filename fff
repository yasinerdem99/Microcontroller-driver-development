/*
 * Bootloader_raw.c
 * RAW HEX YUKLEME MODULU (Ring Buffer + Interrupt)
 */

#include "Bootloader_raw.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

/* --- RENK KODLARI --- */
#define CLR_RESET   "\033[0m"
#define CLR_CYAN    "\033[1;96m"
#define CLR_GREEN   "\033[1;92m"
#define CLR_RED     "\033[1;91m"

/* --- RING BUFFER AYARLARI --- */
#define RING_BUFFER_SIZE  16384
static uint8_t  rb_data[RING_BUFFER_SIZE];
static volatile uint16_t rb_head = 0;
static volatile uint16_t rb_tail = 0;
static uint8_t  rx_byte_it;

/* Global Externs */
extern void Set_Active_Slot(uint32_t new_slot_flag);
extern uint32_t Get_Active_Slot_Addr(void);

/* Değişkenler */
static uint32_t hex_upper_addr = 0;
static uint8_t  smart_buffer[16];
static uint32_t smart_base_addr = 0xFFFFFFFF;
static uint8_t  smart_dirty = 0;

/* ============================================================ */
/* KESME (INTERRUPT) YÖNETİMİ                                   */
/* ============================================================ */

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        rb_data[rb_head++] = rx_byte_it;
        if (rb_head >= RING_BUFFER_SIZE) rb_head = 0;
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

/* ============================================================ */
/* YARDIMCI FONKSİYONLAR                                        */
/* ============================================================ */

static int Ring_Buffer_Read(uint8_t *byte) {
    if (rb_head == rb_tail) return -1;
    *byte = rb_data[rb_tail++];
    if (rb_tail >= RING_BUFFER_SIZE) rb_tail = 0;
    return 0;
}

static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

/* Menü girişi için basit okuma */
static void Raw_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') { printf("\r\n"); buffer[index] = 0; return; }
            if (index < max_len - 1) buffer[index++] = rx_char;
        }
    }
}

static void Flush_Smart_Buffer(void) {
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF) {
        if (Bootloader_Flash_Write(smart_base_addr, smart_buffer, 16) == 0)
            printf("\r\n[HATA] Yazma Basarisiz!\r\n");
        smart_dirty = 0;
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte) {
    uint32_t aligned_base = addr & 0xFFFFFFF0;
    uint8_t offset = addr & 0x0F;
    if (aligned_base != smart_base_addr) {
        Flush_Smart_Buffer();
        memset(smart_buffer, 0xFF, 16);
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }
    smart_buffer[offset] = byte;
    smart_dirty = 1;
}

static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot) {
    if (addr >= 0x08000000 && addr < 0x08010000) return 2;
    if (target_slot == SLOT_A_ADDR && addr >= 0x08010000 && addr < 0x08200000) return 1;
    if (target_slot == SLOT_B_ADDR && addr >= 0x08200000) return 1;
    return 0;
}

/* ============================================================ */
/* ANA FONKSIYON: RAW HEX YUKLEME                               */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    char line_buffer[512];
    uint16_t line_idx = 0;
    uint8_t rx_char;
    uint32_t last_rx_time = 0;
    uint8_t file_started = 0;
    uint32_t current_addr = 0;
    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;
    char sub_cmd[10];
    uint8_t success_flag = 0;

    hex_upper_addr = 0;
    smart_base_addr = 0xFFFFFFFF; smart_dirty = 0; memset(smart_buffer, 0xFF, 16);
    rb_head = 0; rb_tail = 0;

    /* HEDEF SEÇİMİ */
    printf("\r\n" CLR_CYAN "[RAW MODU]" CLR_RESET " Slot Secimi (a/b) > ");
    fflush(stdout);
    Raw_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        printf("HEDEF: SLOT A\r\n");
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        printf("HEDEF: SLOT B\r\n");
    }
    else {
        printf("\r\nIptal.\r\n"); return;
    }

    printf("\r\nHazir. Dosyayi surukleyin... (Bekleniyor)\r\n");

    /* MOTORU BAŞLAT */
    HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    last_rx_time = HAL_GetTick();

    while(1)
    {
        if (Ring_Buffer_Read(&rx_char) == 0)
        {
            last_rx_time = HAL_GetTick();
            file_started = 1;

            if (rx_char == ':') {
                line_idx = 0;
                line_buffer[line_idx++] = ':';
                continue;
            }

            if (rx_char == '\n' || rx_char == '\r')
            {
                if (line_idx > 0) {
                    line_buffer[line_idx] = '\0';

                    if (line_buffer[0] == ':') {
                        uint8_t count = ParseByte(&line_buffer[1]);
                        uint16_t alow = (ParseByte(&line_buffer[3])<<8)|ParseByte(&line_buffer[5]);
                        uint8_t type  = ParseByte(&line_buffer[6]);

                        if (type == 0x04) {
                            hex_upper_addr = (ParseByte(&line_buffer[9])<<8)|ParseByte(&line_buffer[10]);
                        }
                        else if (type == 0x00) {
                            current_addr = (hex_upper_addr << 16) | alow;
                            
                            /* Filtre */
                            if (current_addr < 0x08000000) { line_idx = 0; continue; }

                            if (is_flash_erased == 0) {
                                if (Check_Hex_Address_Range(current_addr, target_slot) != 1) {
                                    printf("\r\n" CLR_RED "[HATA] Adres Uyusmazligi!" CLR_RESET "\r\n");
                                    goto EXIT_TRANSFER;
                                }
                                printf("[INFO] Siliniyor... "); fflush(stdout);
                                if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                    printf("[FAIL]\r\n"); goto EXIT_TRANSFER;
                                }
                                printf("[OK]\r\nYukleniyor"); fflush(stdout);
                                is_flash_erased = 1;
                            }

                            for(int k=0; k<count; k++)
                                Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                        }
                        else if (type == 0x01) {
                            success_flag = 1;
                            goto EXIT_TRANSFER;
                        }
                    }
                    line_idx = 0;
                }
            }
            else {
                if(line_idx < 511) {
                     if ((rx_char >= '0' && rx_char <= '9') || (rx_char >= 'A' && rx_char <= 'F') || (rx_char >= 'a' && rx_char <= 'f') || rx_char == ':')
                        line_buffer[line_idx++] = rx_char;
                }
            }
        }
        else {
            /* Timeout */
            if (file_started && (HAL_GetTick() - last_rx_time > 3000)) {
                if(is_flash_erased) success_flag = 1;
                else printf("\r\n[TIMEOUT] Veri gelmedi.\r\n");
                goto EXIT_TRANSFER;
            }
        }
    }

EXIT_TRANSFER:
    HAL_UART_AbortReceive(&huart3);
    Flush_Smart_Buffer();

    if (success_flag) {
        if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
        else Set_Active_Slot(SLOT_A_ACTIVE);
        printf("\r\n\n" CLR_GREEN "[OK] RAW Yukleme Tamamlandi!" CLR_RESET "\r\n");
    } else {
        printf("\r\n" CLR_RED "[FAIL] Yukleme tamamlanamadi!" CLR_RESET "\r\n");
    }
}
