/*
 * Bootloader_hex.c
 * FULL VERSION: XMODEM + RAW (STM32U5 Native Quad-Word Fix)
 * * COZULEN SORUN: Err: 0x88 (PGAERR | PROGERR)
 * NEDENI: STM32U5 Flash'i sadece 128-bit (16 Byte) bloklar halinde yazilabilir.
 * COZUM: Bootloader_Flash_Write yerine direkt HAL QuadWord komutu eklendi.
 */

#include "Bootloader_hex.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include "stm32u5xx_hal.h" // HAL kutuphanesini ekledik
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

#define RING_BUFFER_SIZE  16384
static uint8_t  rb_data[RING_BUFFER_SIZE];
static volatile uint16_t rb_head = 0;
static volatile uint16_t rb_tail = 0;
static uint8_t  rx_byte_it;

/* --- STM32U5 ICIN 128-BIT (16 BYTE) ALIGNMENT --- */
static uint32_t smart_buffer32[4] __attribute__((aligned(16))); 
static uint8_t *smart_buffer = (uint8_t*)smart_buffer32; 

static uint32_t smart_base_addr = 0xFFFFFFFF;
static uint8_t  smart_dirty = 0;
static uint32_t hex_upper_addr = 0;

/* RENK KODLARI */
#define CLR_RESET   "\033[0m"
#define CLR_CYAN    "\033[1;96m"
#define CLR_GREEN   "\033[1;92m"
#define CLR_RED     "\033[1;91m"
#define CLR_YELLOW  "\033[1;93m"

/* ============================================================ */
/* YARDIMCI FONKSÄ°YONLAR                                        */
/* ============================================================ */

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        rb_data[rb_head++] = rx_byte_it;
        if (rb_head >= RING_BUFFER_SIZE) rb_head = 0;
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART3) {
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

static int Ring_Buffer_Read(uint8_t *byte) {
    if (rb_head == rb_tail) return -1;
    *byte = rb_data[rb_tail++];
    if (rb_tail >= RING_BUFFER_SIZE) rb_tail = 0;
    return 0;
}

static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

static void Hex_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') {
                printf("\r\n"); buffer[index] = 0; return;
            }
            else if (rx_char >= 32 && rx_char <= 126) {
                if (index < max_len - 1) {
                    buffer[index++] = rx_char;
                    HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
                }
            }
        }
    }
}

/* * TAMPONU FLASH'A YAZAN KRITIK FONKSIYON 
 * STM32U5 Icin Ozel Quad-Word (128-bit) Modu Eklendi
 */
static void Flush_Smart_Buffer(void) {
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF) {
        
        // Hatalari temizle ki temiz baslayalim
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
        
        /* * KRITIK DEGISIKLIK:
         * Bootloader_Flash_Write yerine direkt HAL kutuphanesini kullaniyoruz.
         * FLASH_TYPEPROGRAM_QUADWORD = 128 bit (16 byte) yazma modu.
         * (uint32_t)smart_buffer32 -> Tamponun baslangic ADRESI verilir.
         */
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, smart_base_addr, (uint32_t)smart_buffer32) != HAL_OK) 
        {
             uint32_t err = HAL_FLASH_GetError();
             // Hata kodunu detayli bas (0x88 burada yakalanir)
             printf(CLR_RED " [WR ERR Adr:0x%08lX Kod:0x%X]" CLR_RESET, smart_base_addr, (unsigned int)err);
        }
        
        smart_dirty = 0;
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte) {
    uint32_t aligned_base = addr & 0xFFFFFFF0; // 16-byte tabana hizala
    uint8_t offset = addr & 0x0F;

    if (aligned_base != smart_base_addr) {
        Flush_Smart_Buffer();
        memset(smart_buffer, 0xFF, 16); // Yeni 16'lik blogu temizle (FF)
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }
    smart_buffer[offset] = byte;
    smart_dirty = 1;
}

static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot) {
    if ((addr & 0xFF000000) != 0x08000000) return 0;
    if (addr >= 0x08000000 && addr < 0x08010000) return 2;
    if (target_slot == SLOT_A_ADDR && addr >= 0x08010000 && addr < 0x08200000) return 1;
    if (target_slot == SLOT_B_ADDR && addr >= 0x08200000) return 1;
    return 0;
}

/* ============================================================ */
/* FONKSIYON: RAW HEX YUKLEME (RAM BUFFERED)                    */
/* ============================================================ */

#define RAM_FILE_BUFFER_SIZE  48000
static uint8_t g_ram_buffer[RAM_FILE_BUFFER_SIZE];
static uint32_t g_ram_idx = 0;

void Receive_Raw_Hex_File(void)
{
    uint8_t rx_char;
    uint32_t last_rx_time = 0;
    uint8_t file_started = 0;
    uint32_t target_slot = 0;
    char sub_cmd[10];
    char line_buffer[512];
    uint16_t line_idx = 0;
    
    uint32_t written_byte_count = 0;
    uint32_t skipped_byte_count = 0;

    g_ram_idx = 0;
    smart_base_addr = 0xFFFFFFFF;
    smart_dirty = 0;
    memset(smart_buffer, 0xFF, 16);
    rb_head = 0; rb_tail = 0;

    printf("\r\n" CLR_CYAN "[PLAN B: RAW HEX]" CLR_RESET " Slot Secimi (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    /* SMART DEFAULT ADDRESS */
    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        hex_upper_addr = 0x0801; 
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        hex_upper_addr = 0x0820; 
    }
    else { printf("\r\nIptal.\r\n"); return; }

    printf("\r\nDosyayi simdi surukleyin... (Bekleniyor)\r\n");
    __HAL_UART_CLEAR_OREFLAG(&huart3);
    HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    last_rx_time = HAL_GetTick();

    while(1)
    {
        if (Ring_Buffer_Read(&rx_char) == 0) {
            last_rx_time = HAL_GetTick();
            if (!file_started && rx_char == ':') {
                file_started = 1;
                printf("[Start] Veri akisi basladi...\r\n");
            }
            if (file_started) {
                if (g_ram_idx < RAM_FILE_BUFFER_SIZE) g_ram_buffer[g_ram_idx++] = rx_char;
                else { printf(CLR_RED "\r\n[HATA] RAM Buffer Doldu!\r\n" CLR_RESET); goto EXIT_BUFFERED; }
            }
        } else {
            if (file_started && (HAL_GetTick() - last_rx_time > 1000)) {
                printf("\r\n[INFO] Transfer bitti. RAM: %lu bytes.\r\n", g_ram_idx);
                break;
            }
        }
    }

    if (g_ram_idx == 0) {
        printf(CLR_RED "\r\n[HATA] Veri gelmedi.\r\n" CLR_RESET); goto EXIT_BUFFERED;
    }

    /* --- FLASH YAZMA BASLIYOR --- */
    HAL_UART_AbortReceive(&huart3);
    
    HAL_ICACHE_Disable();
    HAL_DCACHE_Disable();
    
    HAL_FLASH_Unlock();
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);

    printf(CLR_YELLOW "Flash Siliniyor... " CLR_RESET); fflush(stdout);
    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
        printf("[FAIL]\r\n"); goto EXIT_BUFFERED;
    }
    printf("[OK]\r\nRAM -> Flash Yaziliyor... (Varsayilan Base: 0x%04X....)\r\n", hex_upper_addr);

    for (uint32_t i = 0; i < g_ram_idx; i++)
    {
        char c = g_ram_buffer[i];
        if (c == ':') { line_idx = 0; line_buffer[line_idx++] = ':'; continue; }

        if (c == '\n' || c == '\r') {
            if (line_idx > 0) { 
                line_buffer[line_idx] = '\0';
                if (line_buffer[0] == ':') {
                    uint8_t count = ParseByte(&line_buffer[1]);
                    uint16_t alow = (ParseByte(&line_buffer[3]) << 8) | ParseByte(&line_buffer[5]);
                    uint8_t type  = ParseByte(&line_buffer[7]);

                    if (type == 0x04) { // Adres Guncelleme
                        uint16_t upper_val = (ParseByte(&line_buffer[9]) << 8) | ParseByte(&line_buffer[11]);
                        if ((upper_val & 0xFF00) == 0x0800) hex_upper_addr = upper_val;
                    }
                    else if (type == 0x00) { // Data
                        uint32_t current_addr = (hex_upper_addr << 16) | alow;
                        if ((current_addr & 0xFF000000) == 0x08000000) {
                            uint8_t range_check = Check_Hex_Address_Range(current_addr, target_slot);
                            if (range_check == 1 || range_check == 2) { 
                                for(int k=0; k<count; k++) {
                                    Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                                }
                                written_byte_count += count;
                            } else skipped_byte_count += count;
                        } else skipped_byte_count += count;
                    }
                }
                line_idx = 0; 
            }
        }
        else if (line_idx < 511) line_buffer[line_idx++] = c;
    }

    Flush_Smart_Buffer(); // Kalan son paketi yaz

    HAL_FLASH_Lock();
    HAL_ICACHE_Enable();
    HAL_DCACHE_Enable();

    printf("\r\n--------------------------------------\r\n");
    printf("Yazilan: %lu bytes | Atlanan: %lu bytes\r\n", written_byte_count, skipped_byte_count);

    if (written_byte_count == 0) {
        printf(CLR_RED "[HATA] Hicbir veri yazilmadi! (Donanim hatasi devam ediyor)\r\n" CLR_RESET);
        goto EXIT_BUFFERED;
    }

    if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
    else Set_Active_Slot(SLOT_A_ACTIVE);

    printf(CLR_GREEN "\r\n[BASARILI] Sistem yeniden baslatiliyor..." CLR_RESET "\r\n");
    HAL_Delay(500);
    HAL_NVIC_SystemReset();
    return;

EXIT_BUFFERED:
    HAL_FLASH_Lock();
    HAL_ICACHE_Enable();
    HAL_DCACHE_Enable();
    printf("\r\n[FAIL] Islem Basarisiz.\r\n");
}
void Xmodem_Receive_Hex_File(void) { printf("[INFO] RAW Mode aktif.\r\n"); }