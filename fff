/*
 * Bootloader_hex.c
 * GUVENLI HEX YUKLEME (Check First, Erase Later)
 */

#include "Bootloader_hex.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

extern void Set_Active_Slot(uint32_t new_slot_flag);

#define SOH 0x01
#define EOT 0x04
#define ACK 0x06
#define NAK 0x15
#define CAN 0x18
#define CHAR_C 'C'

#define CLR_RESET  "\033[0m"
#define CLR_CYAN   "\033[1;96m"
#define CLR_GREEN  "\033[1;92m"
#define CLR_YELLOW "\033[1;93m"


/* HEX Parsing Değişkenleri */
static uint32_t hex_upper_addr = 0;

extern uint32_t Get_Active_Slot_Addr(void);

/* --- SMART BUFFER DEĞİŞKENLERİ --- */
static uint8_t  smart_buffer[16];
static uint32_t smart_base_addr = 0xFFFFFFFF;
static uint8_t  smart_dirty = 0;

/* Yardımcılar */
static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

static uint16_t Calc_CRC16_Hex(const uint8_t *data, uint16_t size) {
    uint16_t crc = 0;
    while (size--) {
        crc ^= (*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
            else crc = crc << 1;
        }
    }
    return crc;
}

static void Hex_Read_Line(char *buffer, uint16_t max_len)
{
    uint16_t index = 0;
    uint8_t rx_char;
    uint8_t backspace_seq[3] = {0x08, 0x20, 0x08};
    memset(buffer, 0, max_len);

    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') {
                printf("\r\n\r\n\r\n");
                buffer[index] = '\0';
                return;
            }
            else if (rx_char == 0x08 || rx_char == 0x7F) {
                if (index > 0) {
                    index--;
                    buffer[index] = '\0';
                    HAL_UART_Transmit(&huart3, backspace_seq, 3, 10);
                }
            }
            else if (rx_char >= 32 && rx_char <= 126) {
                if (index < max_len - 1) {
                    buffer[index++] = rx_char;
                    HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
                }
            }
        }
    }
}

/* --- YAZMA FONKSIYONLARI --- */

static void Flush_Smart_Buffer(void)
{
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF)
    {
        if (Bootloader_Flash_Write(smart_base_addr, smart_buffer, 16) == 0) {
            printf("\r\n[HATA] Yazma Basarisiz! Adr: 0x%08lX\r\n", smart_base_addr);
        }
        smart_dirty = 0;
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte)
{
    uint32_t aligned_base = addr & 0xFFFFFFF0;
    uint8_t offset = addr & 0x0F;

    if (aligned_base != smart_base_addr)
    {
        Flush_Smart_Buffer();
        memset(smart_buffer, 0xFF, 16);
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }

    smart_buffer[offset] = byte;
    smart_dirty = 1;
}

/* --- ADRES KONTROLÜ --- */
static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot)
{
    if (addr >= 0x08000000 && addr < 0x08010000) return 2; // Bootloader Koruması

    if (target_slot == SLOT_A_ADDR) {
        if (addr >= 0x08010000 && addr < 0x08200000) return 1;
    }
    else if (target_slot == SLOT_B_ADDR) {
        if (addr >= 0x08200000) return 1;
    }
    return 0;
}

/* --- ANA FONKSIYON --- */
void Xmodem_Receive_Hex_File(void)
{
    uint8_t rx_buffer[133];
    uint8_t packet_number = 1;
    uint8_t status = 0;
    uint8_t xmodem_done = 0;
    uint8_t hex_parsing_done = 0;

    char line_buffer[128];
    uint8_t line_idx = 0;
    uint8_t in_line = 0;

    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;
    uint8_t rx_char;
    uint32_t total_bytes = 0;

    /* Buffer Sıfırla */
    smart_base_addr = 0xFFFFFFFF;
    smart_dirty = 0;
    memset(smart_buffer, 0xFF, 16);

    /* --- HEDEF BELİRLEME --- */
    uint32_t current_active = Get_Active_Slot_Addr();

    printf("\r\n========================================\r\n");
    if (current_active == SLOT_A_ADDR) {
        target_slot = SLOT_B_ADDR;
        printf(" Mevcut: Flash A (Aktif)\r\n");
        printf(" HEDEF : Flash B (0x%08lX) adresine yuklenecek.\r\n", target_slot);
    } else {
        target_slot = SLOT_A_ADDR;
        printf(" Mevcut: Flash B (Aktif)\r\n");
        printf(" HEDEF : Flash A (0x%08lX) adresine yuklenecek.\r\n", target_slot);
    }
    printf("========================================\r\n");

    printf("Onayliyor musunuz? (y/n) > ");
    fflush(stdout);

    while(1) {
        HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY);
        if (rx_char == 'y' || rx_char == 'Y') break;
        if (rx_char == 'n' || rx_char == 'N') { printf("\r\nIptal.\r\n"); return; }
    }

    /* --- SADELEŞTİRİLMİŞ BEKLEME EKRANI --- */
    /* Yanıp sönme yok, sadece statik yazı var */
    printf("\r\n[HAZIR] Dosya Bekleniyor... (Iptal icin 'e' basin)\r\n");

    uint32_t last_c_time = 0;
    uint8_t handshake_done = 0;

    while (!handshake_done)
    {
        uint32_t current_time = HAL_GetTick();

        /* 1. Saniyede bir 'C' gönder (Arka Planda) */
        if (current_time - last_c_time > 1000) {
            uint8_t c = CHAR_C;
            HAL_UART_Transmit(&huart3, &c, 1, 100);
            last_c_time = current_time;
        }

        /* 2. Veri Dinleme (Yanıp sönme kodu SILINDI) */
        /* Sadece veri gelip gelmediğine bakıyoruz */
        if (HAL_UART_Receive(&huart3, &status, 1, 10) == HAL_OK)
        {
            if (status == 'e' || status == 'E') {
                printf("\r\n[IPTAL] Kullanici iptal etti.\r\n");
                return;
            }
            if (status == SOH) {
                handshake_done = 1;
                /* Ekrana yazı basmıyoruz, direkt işe koyuluyoruz */
            }
        }
    }

    /* --- PAKET DÖNGÜSÜ --- */
    while (!xmodem_done)
    {
        rx_buffer[0] = status; // İlk byte (SOH)

        // Geri kalan 132 byte'ı oku
        if (HAL_UART_Receive(&huart3, &rx_buffer[1], 132, 2000) != HAL_OK) {
            uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
            // Senkron bozulursa tekrar SOH bekle
            HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY);
            continue;
        }

        uint16_t rcrc = (rx_buffer[131] << 8) | rx_buffer[132];
        if (rcrc != Calc_CRC16_Hex(&rx_buffer[3], 128)) {
             uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
             HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY);
             continue;
        }

        /* --- PROGRESS BAR --- */
        total_bytes += 128;
        printf("\r[YUKLENIYOR] Paket: %3d | Toplam: %lu Bytes   ", packet_number, total_bytes);
        fflush(stdout);

        /* --- HEX PARSING --- */
        if (!hex_parsing_done)
        {
            for (int i = 0; i < 128; i++)
            {
                char c = rx_buffer[3 + i];
                if (c == 0x1A) continue;
                if (c == ':') { in_line = 1; line_idx = 0; continue; }

                if (in_line)
                {
                    if (c == '\r' || c == '\n') {
                        in_line = 0;
                        line_buffer[line_idx] = '\0';

                        uint8_t byte_count = ParseByte(&line_buffer[0]);
                        uint16_t addr_low  = (ParseByte(&line_buffer[2]) << 8) | ParseByte(&line_buffer[4]);
                        uint8_t rec_type   = ParseByte(&line_buffer[6]);

                        if (rec_type == 0x00) { // DATA
                            uint32_t current_addr = (hex_upper_addr << 16) | addr_low;

                            /* GUVENLIK VE SILME */
                            if (is_flash_erased == 0)
                            {
                                uint8_t check = Check_Hex_Address_Range(current_addr, target_slot);
                                if (check == 0 || check == 2) {
                                    uint8_t can = CAN;
                                    for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 100);
                                    printf("\r\n\r\n[HATA] Adres Uyusmazligi! Dosya: 0x%08lX\r\n", current_addr);
                                    return;
                                } else {
                                    /* SESSİZ SİLME */
                                    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                        uint8_t can = CAN;
                                        for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 100);
                                        printf("\r\n[HATA] Silme Hatasi!\r\n");
                                        return;
                                    }
                                    is_flash_erased = 1;
                                }
                            }

                            /* Yazma */
                            if (is_flash_erased == 1) {
                                for(int k=0; k<byte_count; k++) {
                                    uint8_t val = ParseByte(&line_buffer[8 + (k*2)]);
                                    Smart_Hex_Write_Byte(current_addr + k, val);
                                }
                            }
                        }
                        else if (rec_type == 0x01) { // EOF
                            Flush_Smart_Buffer();
                            hex_parsing_done = 1;
                        }
                        else if (rec_type == 0x04) { // EXT ADDR
                            uint8_t d1 = ParseByte(&line_buffer[8]);
                            uint8_t d2 = ParseByte(&line_buffer[10]);
                            hex_upper_addr = (d1 << 8) | d2;
                        }
                    }
                    else {
                        if (line_idx < 127) line_buffer[line_idx++] = c;
                    }
                }
            }
        }

        uint8_t ack = ACK;
        HAL_UART_Transmit(&huart3, &ack, 1, 100);
        packet_number++;

        // Sonraki paketin SOH karakterini bekle
        HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY);

        if (status == EOT) {
            HAL_UART_Transmit(&huart3, &ack, 1, 100);
            Flush_Smart_Buffer();
            if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
            else Set_Active_Slot(SLOT_A_ACTIVE);

            xmodem_done = 1;
        }
    }
    printf("\r\n\n" CLR_GREEN "[OK] HEX Yukleme Basariyla Tamamlandi!" CLR_RESET "\r\n");
}

/* ============================================================ */
/* EKSTRA: RAW (RING BUFFER) MODÜLÜ                             */
/* ============================================================ */

/* UART'tan veri geldiğinde işlemci buraya atlar ve veriyi havuza atar */
/* DİKKAT: main.c içinde aynı isimde fonksiyon varsa onu silmelisin! */


/* --- RING BUFFER (HAVUZ) DEĞİŞKENLERİ --- */
/* Bu kısmı dosyanın en tepesine, diğer static değişkenlerin yanına ekle */
#define RING_BUFFER_SIZE  4096

static uint8_t  rb_data[RING_BUFFER_SIZE];
static volatile uint16_t rb_head = 0;
static volatile uint16_t rb_tail = 0;
static uint8_t  rx_byte_it; // Interrupt için geçici değişken
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART3)
    {
        rb_data[rb_head++] = rx_byte_it;
        if (rb_head >= RING_BUFFER_SIZE) rb_head = 0;

        // Dinlemeye devam et
        HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    }
}

/* Havuzdan veri çeker */
static int Ring_Buffer_Read(uint8_t *byte)
{
    if (rb_head == rb_tail) return -1; // Havuz boş
    *byte = rb_data[rb_tail++];
    if (rb_tail >= RING_BUFFER_SIZE) rb_tail = 0;
    return 0; // Veri var
}

/* RAW Yükleme Ana Fonksiyonu */
/*
 * RAW HEX YUKLEME (Degisken Sifirlama Duzeltmesi)
 */
void Receive_Raw_Hex_File(void)
{
    char line_buffer[512];
    uint16_t line_idx = 0;
    uint8_t rx_char;

    uint32_t last_rx_time = 0;
    uint8_t file_started = 0;

    uint32_t current_addr = 0;
    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;
    uint32_t line_count = 0;
    char sub_cmd[10];

    /* --- KRİTİK DÜZELTME: STATİK DEĞİŞKENLERİ SIFIRLA --- */
    /* Bunu yapmazsak bir önceki yüklemeden kalan adres hataya sebep olur */
    hex_upper_addr = 0;
    smart_base_addr = 0xFFFFFFFF;
    smart_dirty = 0;
    memset(smart_buffer, 0xFF, 16);
    rb_head = 0;
    rb_tail = 0;

    /* Hedef Seçimi */
    printf("\r\n" CLR_CYAN "[RAW MODU]" CLR_RESET " Slot Secimi (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        printf("HEDEF: SLOT A\r\n");
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        printf("HEDEF: SLOT B\r\n");
    }
    else {
        printf("\r\nIptal.\r\n"); return;
    }

    printf("\r\nHazir. Dosyayi surukleyin... (Bekleniyor)\r\n");

    /* INTERRUPT BAŞLAT */
    HAL_UART_Receive_IT(&huart3, &rx_byte_it, 1);
    last_rx_time = HAL_GetTick();

    while(1)
    {
        /* Havuzdan Veri Çek */
        if (Ring_Buffer_Read(&rx_char) == 0)
        {
            last_rx_time = HAL_GetTick();

            if (rx_char == '\n' || rx_char == '\r') {
                if (line_idx > 0) {
                    line_buffer[line_idx] = '\0';

                    /* --- HEX PARSING --- */
                    if (line_buffer[0] == ':') {
                        // Sadece geçerli HEX satırı görünce dosya başladı say
                        file_started = 1;

                        uint8_t byte_count = ParseByte(&line_buffer[1]);
                        uint16_t addr_low  = (ParseByte(&line_buffer[3]) << 8) | ParseByte(&line_buffer[5]);
                        uint8_t rec_type   = ParseByte(&line_buffer[7]);

                        /* DATA (00) */
                        if (rec_type == 0x00) {
                            current_addr = (hex_upper_addr << 16) | addr_low;

                            /* Güvenlik ve Silme (Sadece ilk veri satırında) */
                            if (is_flash_erased == 0) {
                                uint8_t check = Check_Hex_Address_Range(current_addr, target_slot);
                                if (check != 1) {
                                    // Hata Detayı Verelim
                                    printf("\r\n[HATA] Adres Uyusmazligi!\r\n");
                                    printf("Dosya: 0x%08lX -> Hedef: 0x%08lX\r\n", current_addr, target_slot);
                                    goto EXIT_TRANSFER;
                                }
                                printf("[INFO] Adres Dogru. Siliniyor..."); fflush(stdout);
                                if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                    printf("[FAIL]\r\n"); goto EXIT_TRANSFER;
                                }
                                printf("[OK]\r\nYukleniyor"); fflush(stdout);
                                is_flash_erased = 1;
                            }

                            /* Veriyi Smart Buffer'a işle */
                            for(int k=0; k<byte_count; k++) {
                                Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                            }

                            /* Görsel Geri Bildirim */
                            line_count++;
                            if(line_count % 50 == 0) { printf("."); fflush(stdout); }
                        }
                        /* EXTENDED LINEAR ADDRESS (04) - Üst adresi güncelle */
                        else if (rec_type == 0x04) {
                            hex_upper_addr = (ParseByte(&line_buffer[9])<<8)|ParseByte(&line_buffer[11]);
                        }
                        /* DOSYA SONU (01) */
                        else if (rec_type == 0x01) {
                            goto FINISH_SUCCESS;
                        }
                    }
                    line_idx = 0;
                }
            }
            else {
                /* Karakter Filtreleme (Sadece HEX karakterler) */
                if(line_idx < 511) {
                    if ((rx_char >= '0' && rx_char <= '9') ||
                        (rx_char >= 'A' && rx_char <= 'F') ||
                        (rx_char >= 'a' && rx_char <= 'f') ||
                        rx_char == ':')
                    {
                        line_buffer[line_idx++] = rx_char;
                    }
                }
            }
        }
        else {
            /* Timeout: Dosya başladıysa ve 2 saniye ses yoksa bitir */
            if (file_started && (HAL_GetTick() - last_rx_time > 2000)) {
                // Eğer hiç veri yazılmadıysa HATA, yazıldıysa BİTTİ say
                if(is_flash_erased) goto FINISH_SUCCESS;
                else {
                    printf("\r\n[TIMEOUT] Veri gelmedi.\r\n");
                    break;
                }
            }
        }
    }

EXIT_TRANSFER:
    HAL_UART_AbortReceive(&huart3);
    printf("\r\n[FAIL] Yukleme basarisiz!\r\n");
    return;

FINISH_SUCCESS:
    HAL_UART_AbortReceive(&huart3);
    Flush_Smart_Buffer();

    if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
    else Set_Active_Slot(SLOT_A_ACTIVE);

    printf("\r\n\n" CLR_GREEN "[OK] RAW Yukleme Tamamlandi!" CLR_RESET "\r\n");
}
