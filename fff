void Receive_Raw_Hex_File(void)
{
    uint8_t c;
    char line_buffer[600];
    uint16_t line_idx = 0;
    uint8_t in_line = 0;

    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;

    char sub_cmd[10];

    smart_base_addr = 0xFFFFFFFF;
    smart_dirty = 0;
    hex_upper_addr = 0;
    memset(smart_buffer, 0xFF, 16);

    rb_head = 0;
    rb_tail = 0;

    /* SLOT SEÇİMİ */
    printf("\r\n" CLR_CYAN "[RAW HEX MODE]" CLR_RESET " Slot Sec (A/B) > ");
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0)
        target_slot = SLOT_A_ADDR;
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0)
        target_slot = SLOT_B_ADDR;
    else
    {
        printf("\r\nIptal edildi.\r\n");
        return;
    }

    printf("\r\n" CLR_GREEN "[READY] .hex dosyasini surukle-birak yap\r\n" CLR_RESET);

    while (1)
    {
        /* Ring buffer’dan karakter oku */
        if (Ring_Buffer_Read(&c) != 0)
            continue;

        if (c == ':')   /* HEX line start */
        {
            in_line = 1;
            line_idx = 0;
            continue;
        }

        if (!in_line)
            continue;

        if (c == '\r' || c == '\n')
        {
            in_line = 0;
            line_buffer[line_idx] = '\0';

            // ---- LINE PARSE ----
            uint8_t count = ParseByte(&line_buffer[0]);
            uint16_t addr_low = (ParseByte(&line_buffer[2]) << 8) | ParseByte(&line_buffer[4]);
            uint8_t type = ParseByte(&line_buffer[6]);

            /* EXTENDED LINEAR ADDRESS */
            if (type == 0x04)
            {
                hex_upper_addr = (ParseByte(&line_buffer[8]) << 8) | ParseByte(&line_buffer[10]);
            }

            /* DATA RECORD */
            else if (type == 0x00)
            {
                uint32_t real_addr = (hex_upper_addr << 16) | addr_low;

                if (real_addr >= 0x08000000)
                {
                    if (is_flash_erased == 0)
                    {
                        if (Check_Hex_Address_Range(real_addr, target_slot) != 1)
                        {
                            printf("\r\n" CLR_RED "[HATA] Yanlis hedef adres!" CLR_RESET "\r\n");
                            return;
                        }

                        if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0)
                        {
                            printf("\r\nFlash silinemedi!\r\n");
                            return;
                        }

                        is_flash_erased = 1;
                    }

                    for (int i = 0; i < count; i++)
                    {
                        uint8_t data = ParseByte(&line_buffer[8 + (i * 2)]);
                        Smart_Hex_Write_Byte(real_addr + i, data);
                    }
                }
            }

            /* EOF */
            else if (type == 0x01)
            {
                Flush_Smart_Buffer();

                if (target_slot == SLOT_A_ADDR)
                    Set_Active_Slot(SLOT_A_ACTIVE);
                else
                    Set_Active_Slot(SLOT_B_ACTIVE);

                printf("\r\n" CLR_GREEN "[OK] RAW HEX yükleme tamamlandi." CLR_RESET "\r\n");
                return;
            }

            continue;
        }

        if (line_idx < sizeof(line_buffer) - 1)
        {
            line_buffer[line_idx++] = c;
        }
    }
}