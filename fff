/*
 * Bootloader_hex.c
 * ULTIMATE VERSION: DMA + CIRCULAR BUFFER
 * (Sürükle Bırak İçin En Sağlam Yöntem - GPDMA Destekli)
 */

#include "Bootloader_hex.h"
#include "Bootloader_flash.h"
#include "Bootloader_config.h" 
#include <stdio.h>
#include <string.h>

extern UART_HandleTypeDef huart3;

/* DMA COUNTER MAKROSU (STM32U5 GPDMA İçin) */
/* U5 serisinde __HAL_DMA_GET_COUNTER bazen farklı çalışabilir.
   En garantisi linked list kullanmıyorsak standart makrodur. */
#define GET_DMA_COUNTER(handle) __HAL_DMA_GET_COUNTER(handle)

#define SOH 0x01
#define EOT 0x04
#define ACK 0x06
#define NAK 0x15
#define CAN 0x18
#define CHAR_C 'C'

/* --- DMA BUFFER AYARLARI --- */
#define DMA_RX_BUFFER_SIZE  16384  // 16KB DMA Tamponu (Büyük tutalim)
/* Buffer'ı belirli bir bölgeye (SRAM1) koymak iyi olabilir ama 
   U5'te otomatik yerleşim de çalışır. */
static uint8_t dma_rx_buffer[DMA_RX_BUFFER_SIZE];
static uint32_t rb_tail = 0;

/* Parsing Değişkenleri */
static uint32_t hex_upper_addr = 0;
static uint8_t  smart_buffer[16];       
static uint32_t smart_base_addr = 0xFFFFFFFF; 
static uint8_t  smart_dirty = 0;        

/* ============================================================ */
/* YARDIMCI FONKSİYONLAR                                        */
/* ============================================================ */

/* DMA'dan Veri Okuma Motoru */
/* Bu fonksiyon, DMA'nın doldurduğu ama bizim henüz okumadığımız
   verileri "tail" indeksini kullanarak çeker. */
static int DMA_Read_Byte(uint8_t *byte)
{
    /* DMA sayacı azalarak gider (Size -> 0) */
    /* huart3.hdmarx -> UART'ın bağlı olduğu DMA kanalı */
    uint32_t dma_counter = GET_DMA_COUNTER(huart3.hdmarx);
    
    /* Head pozisyonunu hesapla (Yazılan son yer) */
    uint32_t rb_head = DMA_RX_BUFFER_SIZE - dma_counter;

    /* Eğer kuyruk başı yakaladıysa veri yok demektir */
    if (rb_tail == rb_head) {
        return -1; // Okunacak yeni veri yok
    }

    /* Veriyi al ve kuyruğu ilerlet */
    *byte = dma_rx_buffer[rb_tail];
    rb_tail = (rb_tail + 1) % DMA_RX_BUFFER_SIZE;

    return 0; // Veri okundu
}

static uint8_t HexCharToByte(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static uint8_t ParseByte(char* ptr) {
    return (HexCharToByte(ptr[0]) << 4) | HexCharToByte(ptr[1]);
}

static uint16_t Calc_CRC16_Hex(const uint8_t *data, uint16_t size) {
    uint16_t crc = 0;
    while (size--) {
        crc ^= (*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021; else crc = crc << 1;
        }
    }
    return crc;
}

static void Hex_Read_Line(char *buffer, uint16_t max_len) {
    uint16_t index = 0; uint8_t rx_char; memset(buffer, 0, max_len);
    while(1) {
        if (HAL_UART_Receive(&huart3, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK) {
            if (rx_char == '\r' || rx_char == '\n') { 
                printf("\r\n"); buffer[index] = 0; return; 
            }
            if (index < max_len - 1) {
                buffer[index++] = rx_char;
                HAL_UART_Transmit(&huart3, &rx_char, 1, 10);
            }
        }
    }
}

static void Flush_Smart_Buffer(void) {
    if (smart_dirty && smart_base_addr != 0xFFFFFFFF) {
        if (Bootloader_Flash_Write(smart_base_addr, smart_buffer, 16) == 0) 
            printf("\r\n[HATA] Yazma Basarisiz! Adr: 0x%08lX\r\n", smart_base_addr);
        smart_dirty = 0; 
    }
}

static void Smart_Hex_Write_Byte(uint32_t addr, uint8_t byte) {
    uint32_t aligned_base = addr & 0xFFFFFFF0;
    uint8_t offset = addr & 0x0F;
    if (aligned_base != smart_base_addr) {
        Flush_Smart_Buffer(); 
        memset(smart_buffer, 0xFF, 16); 
        smart_base_addr = aligned_base;
        smart_dirty = 0;
    }
    smart_buffer[offset] = byte;
    smart_dirty = 1; 
}

static uint8_t Check_Hex_Address_Range(uint32_t addr, uint32_t target_slot) {
    if (addr >= 0x08000000 && addr < 0x08010000) return 2;
    if (target_slot == SLOT_A_ADDR && addr >= 0x08010000 && addr < 0x08200000) return 1;
    if (target_slot == SLOT_B_ADDR && addr >= 0x08200000) return 1;
    return 0;
}

/* ============================================================ */
/* XMODEM FONKSİYONU (Standart - Dokunulmadi)                   */
/* ============================================================ */
void Xmodem_Receive_Hex_File(void)
{
    /* XMODEM kodunu buraya olduğu gibi yapıştır (Eski kodundan al) */
    /* DMA ile çakışmaz çünkü burada DMA başlatmıyoruz */
}

/* ============================================================ */
/* RAW HEX YUKLEME (DMA Destekli - 0ms Gecikme)                 */
/* ============================================================ */
void Receive_Raw_Hex_File(void)
{
    char line_buffer[512]; 
    uint16_t line_idx = 0; 
    uint8_t rx_char;
    uint32_t last_rx_time = 0; 
    uint8_t file_started = 0;
    
    uint32_t current_addr = 0; 
    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0; 
    uint32_t byte_counter = 0;
    
    char sub_cmd[10];
    uint8_t success_flag = 0;

    /* Reset */
    hex_upper_addr = 0;
    smart_base_addr = 0xFFFFFFFF; smart_dirty = 0; memset(smart_buffer, 0xFF, 16);
    
    /* DMA Tail Reset */
    rb_tail = 0;

    /* --- HEDEF SEÇİMİ --- */
    printf("\r\n" "\033[1;96m" "[RAW DMA]" "\033[0m" " Slot Secimi (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) target_slot = SLOT_A_ADDR;
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) target_slot = SLOT_B_ADDR;
    else { printf("\r\nIptal.\r\n"); return; }

    printf("\r\nHazir. Dosyayi surukleyin... (DMA Modu)\r\n");

    /* --- DMA BAŞLAT (CIRCULAR MODE) --- */
    /* Bu komut, UART'tan gelen verileri arka planda sonsuz döngüde tampona atar */
    HAL_UART_Receive_DMA(&huart3, dma_rx_buffer, DMA_RX_BUFFER_SIZE);
    
    last_rx_time = HAL_GetTick();

    while(1)
    {
        /* DMA Havuzundan Veri Çek */
        if (DMA_Read_Byte(&rx_char) == 0) 
        {
            last_rx_time = HAL_GetTick();
            file_started = 1;

            if (rx_char == ':') {
                line_idx = 0;
                line_buffer[line_idx++] = ':'; 
                continue; 
            }

            if ((rx_char == '\n' || rx_char == '\r') && line_idx > 0) 
            {
                line_buffer[line_idx] = '\0';
                
                if (line_buffer[0] == ':') {
                    uint8_t count = ParseByte(&line_buffer[1]);
                    uint16_t alow = (ParseByte(&line_buffer[3])<<8)|ParseByte(&line_buffer[5]);
                    uint8_t type  = ParseByte(&line_buffer[7]);
                    
                    if (type == 0x04) { 
                        hex_upper_addr = (ParseByte(&line_buffer[9])<<8)|ParseByte(&line_buffer[11]);
                    }
                    else if (type == 0x00) { 
                        current_addr = (hex_upper_addr << 16) | alow;
                        
                        /* FİLTRE: Geçersiz adresleri yoksay */
                        if (current_addr < 0x08000000) { line_idx = 0; continue; }

                        if (is_flash_erased == 0) {
                            if (Check_Hex_Address_Range(current_addr, target_slot) != 1) {
                                printf("\r\n[HATA] Adres: 0x%08lX\r\n", current_addr); goto EXIT_TRANSFER; 
                            }
                            printf("[INFO] Siliniyor... "); fflush(stdout);
                            if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                printf("[FAIL]\r\n"); goto EXIT_TRANSFER;
                            }
                            printf("[OK] Yukleniyor\r\n"); fflush(stdout);
                            is_flash_erased = 1;
                        }
                        
                        for(int k=0; k<count; k++) {
                            Smart_Hex_Write_Byte(current_addr + k, ParseByte(&line_buffer[9+(k*2)]));
                        }
                        
                        byte_counter += count;
                        if(byte_counter % 2048 == 0) { printf("."); fflush(stdout); }
                    }
                    else if (type == 0x01) { 
                        success_flag = 1;
                        goto EXIT_TRANSFER;
                    }
                }
                line_idx = 0;
            } 
            else {
                /* Karakter Filtreleme */
                if(line_idx < 511) {
                    if ((rx_char >= '0' && rx_char <= '9') || 
                        (rx_char >= 'A' && rx_char <= 'F') || 
                        (rx_char >= 'a' && rx_char <= 'f') || 
                        rx_char == ':') 
                    {
                        line_buffer[line_idx++] = rx_char;
                    }
                }
            }
        }
        else {
            /* Timeout: 3 sn veri gelmezse */
            if (file_started && (HAL_GetTick() - last_rx_time > 3000)) {
                if(is_flash_erased) success_flag = 1; // Tolerans
                else printf("\r\n[TIMEOUT] Veri gelmedi.\r\n");
                goto EXIT_TRANSFER;
            }
        }
    }

EXIT_TRANSFER:
    /* DMA DURDUR */
    HAL_UART_DMAStop(&huart3);
    
    Flush_Smart_Buffer(); 
    
    if (success_flag) {
        if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
        else Set_Active_Slot(SLOT_A_ACTIVE);
        printf("\r\n\n[OK] RAW Yukleme Tamamlandi! (%lu Bytes)\r\n", byte_counter);
    } else {
        printf("\r\n[FAIL] Yukleme tamamlanamadi!\r\n");
    }
}
