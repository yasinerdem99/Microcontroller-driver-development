/*
 * Bootloader_core.c
 * MANUEL KONTROL VERSIYONU (Secmeli Yukleme ve Atlama)
 */

#include "main.h"
#include <stdio.h>
#include "Bootloader_flash.h"
#include "Bootloader_config.h"
#include "Bootloader_hex.h"
#include "Bootloader_hex_raw.h"

extern UART_HandleTypeDef huart1;

#define SOH 0x01
#define EOT 0x04
#define ACK 0x06
#define NAK 0x15
#define CAN 0x18
#define CHAR_C 'C'

/* --- BU KISMI EN TEPEYE EKLE --- */
#include <string.h>  // <--- BU COK ONEMLI!

/* Renk Kodları */
#define CLR_RESET   "\033[0m"
#define CLR_RED     "\033[31m"
#define CLR_GREEN   "\033[32m"
#define CLR_YELLOW  "\033[33m"
#define CLR_CYAN    "\033[36m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[35m"
#define CLR_WHITE   "\033[37m"

/* Kullanıcı Ayarları */
#define USER_NAME       "yerdem"
#define PROMPT_TEXT     "cboot > "
#define CMD_BUFFER_LEN  64

/* --- PROTOTIPLER --- */
void Xmodem_Receive_File(void);
void Bootloader_Jump_To_Address(uint32_t jump_addr);
uint8_t Verify_Firmware_Address(uint32_t target_slot, uint8_t *data_buffer);
uint32_t Get_Active_Slot_Addr(void);
void Set_Active_Slot(uint32_t new_slot_flag);
uint16_t Calc_CRC16(const uint8_t *data, uint16_t size);
/* ------------------- */

/* --- BU FONKSIYONLARI MENU LOOP'UN USTUNE YAPISTIR --- */

/* 1.  Logo Basma Fonksiyonu */
void Bootloader_Print_Logo(void)
{
	/* 1. Havali ve Buyuk Logo Basma Fonksiyonu */


	    printf("\033[2J\033[H");

	    HAL_Delay(10);// Ekrani temizle




		printf(CLR_RED "                       ++                                        \r\n");
		printf(CLR_RED "                        +++                                      \r\n");
		printf(CLR_RED "                        ++++                                     \r\n");
		printf(CLR_RED "                         ++++                                    \r\n");
		printf(CLR_RED "                          +++                                    \r\n");
		printf(CLR_RED "                     +++   +++                                   \r\n");
		printf(CLR_RED "                      +++   +++                                  \r\n");
		printf(CLR_RED "                       +++   ++                                  \r\n");
		printf(CLR_RED "                       +++   +++                                 \r\n");
		printf(CLR_RED "                        +++   +++                                \r\n");
		printf(CLR_RED " +++++++++++++++++++++  ++++  ++++++++++++++++++++++             \r\n");
		printf(CLR_RED " +++++                                        ++++               \r\n");
		printf(CLR_RED "   +++++                                   ++++                  \r\n");
		printf(CLR_RED "     +++++                              +++++                    \r\n");
		printf(CLR_RED "       +++++                          +++++                      \r\n");
		printf(CLR_RED "         +++++                      ++++                         \r\n");
		printf(CLR_RED "            +++                     +++                          \r\n");
		printf(CLR_RED "            +++                   ++++                           \r\n");
		printf(CLR_RED "           +++             ++++   +++                            \r\n");
		printf(CLR_RED "           +++       ++     +++    +++                           \r\n");
		printf(CLR_RED "          +++      +++++     +++   +++                           \r\n");
		printf(CLR_RED "         +++    +++++         +++   +++                          \r\n");
		printf(CLR_RED "         +++  ++++             +++   ++                          \r\n");
		printf(CLR_RED "       +++ +++++                +++   +++                        \r\n");
		printf(CLR_RED "      +++++++                          +++                       \r\n");
		printf(CLR_RED "     ++++++                             ++++                     \r\n");
		printf(CLR_RED "      ++                                 ++  					 \r\n");

	        /* --- HAVELSAN YAZISI (HER SATIRA CLR_WHITE EKLENDI) --- */




printf(CLR_WHITE " __    __       ___   ____    ____  _______  __          _______.     ___      .__   __.           \r\n");
printf(CLR_WHITE "|  |  |  |     /   \\  \\   \\  /   / |   ____||  |        /       |    /   \\     |  \\ |  |      \r\n");
printf(CLR_WHITE "|  |__|  |    /  ^  \\  \\   \\/   /  |  |__   |  |       |   (----`   /  ^  \\    |   \\|  |      \r\n");
printf(CLR_WHITE "|   __   |   /  /_\\  \\  \\      /   |   __|  |  |        \\   \\      /  /_\\  \\   |  . `  |     \r\n");
printf(CLR_WHITE "|  |  |  |  /  _____  \\  \\    /    |  |____ |  `----.----)   |    /  _____  \\  |  |\\   |        \r\n");
printf(CLR_WHITE "|__|  |__| /__/     \\__\\  \\__/     |_______||_______|_______/    /__/     \\__\\ |__| \\__|      \r\n");





	    printf(CLR_RESET);

	    uint32_t active_slot = Get_Active_Slot_Addr();

	    printf("\r\n");
	        printf(CLR_CYAN   "   User  : " CLR_WHITE "%s" CLR_RESET "\r\n", USER_NAME);
	        printf(CLR_YELLOW "   Board : " CLR_WHITE "STM32U5A9" CLR_YELLOW " | Unit: " CLR_WHITE "RTOS Embedded Software" CLR_RESET "\r\n");

	        /* AKTIF SLOT GOSTERGESI */
	        if (active_slot == SLOT_A_ADDR) {
	            printf(CLR_GREEN  "   STATUS: [ AKTIF FLASH: A ]" CLR_RESET "\r\n");
	        } else {
	            printf(CLR_MAGENTA "   STATUS: [ AKTIF FLASH: B ]" CLR_RESET "\r\n");
	        }

	        printf("   ---------------------------------------------------------------------------\r\n");
	        printf(CLR_GREEN  "   Komutlar: help, boot, load_bin, load_hex, flash_a, flash_b, reboot, clear" CLR_RESET "\r\n\n");

}

void Print_Help_Menu(void)
{
    printf(CLR_CYAN);
    printf(" +----------+--------------------------------------------------+\r\n");
    printf(" | KOMUT    | ACIKLAMA                                         |\r\n");
    printf(" +----------+--------------------------------------------------+\r\n");
    printf(CLR_RESET);

    printf(" | " CLR_BOLD "boot" CLR_RESET "     | Aktif olan slottaki uygulamayi baslatir          |\r\n");
    printf(" | " CLR_BOLD "load_bin" CLR_RESET " | Bin yazilim yukleme sihirbazini acar             |\r\n");
    printf(" | " CLR_BOLD "load_hex" CLR_RESET " | Hex yazilim yukleme sihirbazini acar             |\r\n");
    printf(" | " CLR_BOLD "flash_a" CLR_RESET "  | FLASH A (Bank 1) uygulamasina atlar              |\r\n");
    printf(" | " CLR_BOLD "flash_b" CLR_RESET "  | FLASH B (Bank 2) uygulamasina atlar              |\r\n");
    printf(" | " CLR_BOLD "info" CLR_RESET "     | Sistem ve Slot adres bilgilerini gosterir        |\r\n");
    printf(" | " CLR_BOLD "reboot" CLR_RESET "   | Cihaza donanimsal reset atar                     |\r\n");
    printf(" | " CLR_BOLD "clear" CLR_RESET "    | Ekrani temizler ve logoyu tekrar basar           |\r\n");

    printf(CLR_CYAN);
    printf(" +----------+--------------------------------------------------+\r\n");
    printf(CLR_RESET "\r\n");
}
/* 2. Satır Okuma Fonksiyonu (Enter'a basana kadar bekler) */
void CLI_Read_Line(char *buffer, uint16_t max_len)
{
    uint16_t index = 0;
    uint8_t rx_char;

    /* Silme Efekti İçin Özel Dizi: [Geri Git] [Boşluk Bas] [Geri Git] */
    uint8_t backspace_seq[3] = {0x08, 0x20, 0x08};

    memset(buffer, 0, max_len);

    while(1)
    {
        if (HAL_UART_Receive(&huart1, &rx_char, 1, HAL_MAX_DELAY) == HAL_OK)
        {
            /* --- ENTER TUSU --- */
            if (rx_char == '\r' || rx_char == '\n') {
                printf("\r\n\r\n\r\n"); // 3 satir bosluk
                buffer[index] = '\0';
                return;
            }

            /* --- BACKSPACE TUSU  --- */
            else if (rx_char == 0x08 || rx_char == 0x7F) {
                if (index > 0) {
                    index--;
                    buffer[index] = '\0'; // Hafızadan sil

                    /* EKRANDAN SILME (Printf yerine HAL kullanıyoruz) */
                    /* Bu komut anında gönderilir ve harfi siler */
                    HAL_UART_Transmit(&huart1, backspace_seq, 3, 10);
                }
            }

            /* --- NORMAL KARAKTER --- */
            else {
                // Sadece yazilabilir karakterleri al
                if (rx_char >= 32 && rx_char <= 126) {
                    if (index < max_len - 1) {
                        buffer[index++] = rx_char;
                        // Ekrana bas (Echo)
                        HAL_UART_Transmit(&huart1, &rx_char, 1, 10);
                    }
                }
            }
        }
    }
}

uint32_t Get_Active_Slot_Addr(void)
{
    uint32_t config_val = *(volatile uint32_t*)CONFIG_PAGE_ADDR;
    if (config_val == SLOT_B_ACTIVE) return SLOT_B_ADDR;
    return SLOT_A_ADDR;
}

void Set_Active_Slot(uint32_t new_slot_flag)
{
    FLASH_EraseInitTypeDef EraseInitStruct;
    uint32_t PageError;

    HAL_FLASH_Unlock();
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);

    EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
    EraseInitStruct.Banks       = FLASH_BANK_1;
    EraseInitStruct.Page        = (CONFIG_PAGE_ADDR - FLASH_BASE) / 0x2000;
    EraseInitStruct.NbPages     = 1;

    HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);

    uint32_t data_pack[4] = {new_slot_flag, 0, 0, 0};
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, CONFIG_PAGE_ADDR, (uint32_t)data_pack);

    HAL_FLASH_Lock();
}

uint16_t Calc_CRC16(const uint8_t *data, uint16_t size) {
    uint16_t crc = 0;
    while (size--) {
        crc ^= (*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
            else crc = crc << 1;
        }
    }
    return crc;
}

uint8_t Verify_Firmware_Address(uint32_t target_slot, uint8_t *data_buffer)
{
    uint32_t reset_handler_addr = *((uint32_t*)&data_buffer[3 + 4]);
    printf("\r\n[ANALIZ] Dosya Reset Vektoru: 0x%08lX\r\n", reset_handler_addr);

    if (target_slot == SLOT_A_ADDR) {
        if (reset_handler_addr >= 0x08010000 && reset_handler_addr < 0x08200000) return 1;
    }
    else if (target_slot == SLOT_B_ADDR) {
        if (reset_handler_addr >= 0x08200000) return 1;
    }

    if (reset_handler_addr >= 0x08000000 && reset_handler_addr < 0x08010000) {
         printf("[UYARI] BOOTLOADER dosyasini yuklemeye calisiyorsunuz!\r\n");
    } else {
         printf("[UYARI] Dosya adresi, sectiginiz Slot (%s) ile uyuşmuyor!\r\n", (target_slot == SLOT_A_ADDR) ? "A" : "B");
    }

    return 0;
}

void Xmodem_Receive_File(void)
{
    uint8_t rx_buffer[133];
    uint8_t packet_number = 1;
    uint8_t status;
    uint8_t rx_char;
    uint8_t first_packet_received = 0;
    uint32_t target_address = 0;

    /* --- ADIM 1: KULLANICIYA HEDEF SOR --- */
    uint32_t current_active = Get_Active_Slot_Addr();

    printf("========================================\r\n");

    if (current_active == SLOT_A_ADDR) {
    	target_address = SLOT_B_ADDR;
        printf("[BILGI] Mevcut surum: Flash A \r\n");
        printf("HEDEF: Yeni surum :Flash B (0x%08lX) adresine yuklenecektir\r\n", target_address);
    }
    else  {
    	target_address = SLOT_A_ADDR;
        printf("[BILGI] Mevcut surum: Flash B \r\n");
        printf("HEDEF: Yeni surum :Flash A (0x%08lX) adresine yuklenecektir\r\n", target_address);
    }

    printf("========================================\r\n");



    printf("Dikkat! Hedef Slot Silinecek. Onayliyor musunuz? (y/n) > \r\n");
    while(1) {
        HAL_UART_Receive(&huart1, &rx_char, 1, HAL_MAX_DELAY);
        if (rx_char == 'y' || rx_char == 'Y') break;
        if (rx_char == 'n' || rx_char == 'N') { printf("Iptal.\r\n"); return; }
    }



    uint32_t write_ptr = target_address;

    /* Handshake */
    printf("\r\n[HAZIR] Dosya Bekleniyor... (Iptal icin 'e' basin)\r\n");

     uint32_t last_c_time = 0;
     uint8_t handshake_done = 0;

     while (!handshake_done)
     {
         uint32_t current_time = HAL_GetTick();

         /* 1. Saniyede bir 'C' gönder (Arka Planda) */
         if (current_time - last_c_time > 1000) {
             uint8_t c = CHAR_C;
             HAL_UART_Transmit(&huart1, &c, 1, 100);
             last_c_time = current_time;
         }

         /* 2. Veri Dinleme (Yanıp sönme kodu SILINDI) */
         /* Sadece veri gelip gelmediğine bakıyoruz */
         if (HAL_UART_Receive(&huart1, &status, 1, 10) == HAL_OK)
         {
             if (status == 'e' || status == 'E') {
                 printf("\r\n[IPTAL] Kullanici iptal etti.\r\n");
                 return;
             }
             if (status == SOH) {
                 handshake_done = 1;
                 /* Ekrana yazı basmıyoruz, direkt işe koyuluyoruz */
             }
         }
     }

    /* Paket Döngüsü */
    while (1) {
        rx_buffer[0] = status;

        if (HAL_UART_Receive(&huart1, &rx_buffer[1], 132, 2000) != HAL_OK) {
            uint8_t nack=NAK; HAL_UART_Transmit(&huart1, &nack, 1, 100);
            HAL_UART_Receive(&huart1, &status, 1, HAL_MAX_DELAY); continue;
        }

        if (rx_buffer[1] != packet_number || rx_buffer[2] != (uint8_t)(255 - packet_number)) {
            uint8_t nack=NAK; HAL_UART_Transmit(&huart1, &nack, 1, 100);
            HAL_UART_Receive(&huart1, &status, 1, HAL_MAX_DELAY); continue;
        }

        uint16_t received_crc = (rx_buffer[131] << 8) | rx_buffer[132];
        uint16_t calculated_crc = Calc_CRC16(&rx_buffer[3], 128);

        if (received_crc != calculated_crc) {
             uint8_t nack=NAK; HAL_UART_Transmit(&huart1, &nack, 1, 100);
             HAL_UART_Receive(&huart1, &status, 1, HAL_MAX_DELAY); continue;
        }

        /* --- KONTROL VE SILME --- */
        if (first_packet_received == 0)
        {
            // Kullanıcının seçtiği slota göre dosyayı doğrula
            if (Verify_Firmware_Address(target_address, rx_buffer) == 0)
            {
                uint8_t can = CAN;
                for(int i=0; i<5; i++) HAL_UART_Transmit(&huart1, &can, 1, 10);

                uint8_t trash;
                while(HAL_UART_Receive(&huart1, &trash, 1, 50) == HAL_OK); // Çöp temizle

                printf("\r\n\r\n[HATA] SECILEN SLOT ILE DOSYA UYUSMUYOR!\r\n");
                printf("Islem Iptal Edildi.\r\n");
                return;
            }

            printf("[OK] Dosya Uygun. Siliniyor... \r\n");

            if (Bootloader_Flash_Erase_Target_Slot(target_address) == 0) {
                uint8_t can = CAN; HAL_UART_Transmit(&huart1, &can, 1, 100);
                printf("\r\n[HATA] Silme basarisiz!\r\n");
                return;
            }
            first_packet_received = 1;
        }

        /* Yazma */
        uint8_t ack=ACK, can=CAN;
        if (Bootloader_Flash_Write(write_ptr, &rx_buffer[3], 128)) {
            write_ptr += 128;
            packet_number++;
            HAL_UART_Transmit(&huart1, &ack, 1, 100);
        } else {
            HAL_UART_Transmit(&huart1, &can, 1, 100);
            printf("\r\nWrite Failed!\r\n");
            return;
        }

        /* Bitiş */
        HAL_UART_Receive(&huart1, &status, 1, HAL_MAX_DELAY);
        if (status == EOT) {
            HAL_UART_Transmit(&huart1, &ack, 1, 100);
            printf("\r\nYukleme Basarili!\r\n");

            /* Yukleme yapilan slotu AKTIF olarak işaretle */
            if (target_address == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
            else Set_Active_Slot(SLOT_A_ACTIVE);

            return;
        }
    }
}


void Bootloader_Menu_Loop(void)
{
    char cmd_buffer[CMD_BUFFER_LEN];
    uint32_t active_slot;

    /* Açılışta Logoyu Bas */
    Bootloader_Print_Logo();

    while(1)
    {
        active_slot = Get_Active_Slot_Addr();

        /* Prompt */
        printf(CLR_MAGENTA CLR_BOLD "%s" CLR_RESET, PROMPT_TEXT);
        fflush(stdout);

        /* Komut Bekle */
        CLI_Read_Line(cmd_buffer, CMD_BUFFER_LEN);

        /* Boş enter basıldıysa sadece yeni satır ver */
        if (strlen(cmd_buffer) == 0) continue;

        /* --- KOMUTLAR --- */

        if (strcmp(cmd_buffer, "help") == 0 || strcmp(cmd_buffer, "?") == 0) {
            Print_Help_Menu();
        }
        else if (strcmp(cmd_buffer, "boot") == 0) {
            printf("Uygulama baslatiliyor...\r\n");
            Bootloader_Jump_To_Address(active_slot);
            printf(CLR_RED "[HATA] Slot bos!" CLR_RESET "\r\n\n");
        }
        else if (strcmp(cmd_buffer, "load_bin") == 0) {
            Xmodem_Receive_File();
            HAL_Delay(1000);

        }
        else if (strcmp(cmd_buffer, "flash_a") == 0) {
            printf("SLOT A'ya geciliyor...\r\n");
            HAL_Delay(500);
            Bootloader_Jump_To_Address(SLOT_A_ADDR);
        }
        else if (strcmp(cmd_buffer, "flash_b") == 0) {
            printf("SLOT B'ye geciliyor...\r\n");
            HAL_Delay(500);
            Bootloader_Jump_To_Address(SLOT_B_ADDR);
        }
        else if (strcmp(cmd_buffer, "reboot") == 0) {
            HAL_NVIC_SystemReset();
        }
        else if (strcmp(cmd_buffer, "clear") == 0) {
            Bootloader_Print_Logo();
        }
        else if (strcmp(cmd_buffer, "load_hex") == 0) {
             Xmodem_Receive_Hex_File();
             HAL_Delay(1000);
        }
        else if (strcmp(cmd_buffer, "load_raw") == 0) {
             Receive_Raw_Hex_File();
             HAL_Delay(1000);
        }
        else {
            printf(CLR_RED "Bilinmeyen komut: '%s'" CLR_RESET "\r\n\n", cmd_buffer);
        }
    }
}

/* Parametre olarak adres alan yeni Jump fonksiyonu */
void Bootloader_Jump_To_Address(uint32_t jump_addr)
{
    uint32_t mspValue = *(volatile uint32_t*) jump_addr;
    uint32_t resetValue = *(volatile uint32_t*) (jump_addr + 4);

    /* 1. Adres Kontrolü */
    if (mspValue == 0xFFFFFFFF) {
        printf(CLR_RED "\r\n[HATA] Bu slot bos (Veri yok)!\r\n" CLR_RESET);
        return;
    }

    printf("\r\n" CLR_GREEN "[INFO] Gecis yapiliyor: 0x%08lX" CLR_RESET "\r\n", jump_addr);

    /* Mesajın gitmesi için azıcık bekle */
    HAL_Delay(100);

    /* === SADELEŞTİRİLMİŞ GEÇİŞ === */

    /* 1. Sadece SysTick'i durdur (Zamanlama karışmasın diye) */
    SysTick->CTRL = 0;
    SysTick->LOAD = 0;
    SysTick->VAL  = 0;

    /* 2. Kesmeleri KAPATMA! (Application açık bekliyor olabilir) */
    // __disable_irq();   <-- BU SATIR SILINDI

    /* 3. Donanımları KAPATMA! (HAL_DeInit yok) */
    // HAL_DeInit();      <-- BU SATIR SILINDI
    // HAL_RCC_DeInit();  <-- BU SATIR SILINDI

    /* 4. Vektör Tablosunu Kaydır (Zorunlu) */
    SCB->VTOR = jump_addr;

    /* 5. Atla */
    void (*app_reset_handler)(void);

    __set_MSP(mspValue);

    app_reset_handler = (void*) resetValue;
    app_reset_handler();
}
