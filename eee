/* Core/Src/Bootloader_hex.c İçindeki Fonksiyonu Bununla Değiştir */

void Xmodem_Receive_Hex_File(void)
{
    uint8_t rx_buffer[133]; 
    uint8_t packet_number = 1;
    uint8_t status;
    uint8_t xmodem_done = 0;
    uint8_t hex_parsing_done = 0;
    
    char line_buffer[128];
    uint8_t line_idx = 0;
    uint8_t in_line = 0;
    
    char sub_cmd[10];
    uint32_t target_slot = 0;
    uint8_t is_flash_erased = 0;
    
    uint32_t total_bytes = 0; // İlerleme sayacı

    /* Smart Buffer Sıfırla */
    // (Static değişkenleri resetlemek için yardımcı fonksiyonun yoksa manuel yap)
    // smart_base_addr = 0xFFFFFFFF; smart_dirty = 0; memset(smart_buffer, 0xFF, 16);

    /* --- HEDEF SEÇİMİ --- */
    printf("\r\n" CLR_CYAN "[HEX MODU]" CLR_RESET " Hangi Slota Yukleme Yapilacak? (a/b) > ");
    fflush(stdout);
    Hex_Read_Line(sub_cmd, 10);

    if (strcmp(sub_cmd, "a") == 0 || strcmp(sub_cmd, "A") == 0) {
        target_slot = SLOT_A_ADDR;
        printf("HEDEF: SLOT A (0x%08lX)\r\n", target_slot);
    }
    else if (strcmp(sub_cmd, "b") == 0 || strcmp(sub_cmd, "B") == 0) {
        target_slot = SLOT_B_ADDR;
        printf("HEDEF: SLOT B (0x%08lX)\r\n", target_slot);
    }
    else {
        printf("\r\n[IPTAL] Gecersiz secim.\r\n");
        return;
    }

    /* --- GELİŞMİŞ BEKLEME EKRANI (BLINK & 'C' HANDSHAKE) --- */
    printf(CLR_YELLOW "Hazir. Bekleniyor... (Iptal icin 'e' basin)\r\n" CLR_RESET);
    
    uint32_t last_c_time = 0;
    uint32_t last_blink_time = 0;
    uint8_t blink_state = 0;
    uint8_t handshake_done = 0;

    while (!handshake_done) 
    {
        uint32_t current_time = HAL_GetTick();

        /* 1. Saniyede bir 'C' gönder (XMODEM Başlatıcı) */
        if (current_time - last_c_time > 1000) {
            uint8_t c = CHAR_C;
            HAL_UART_Transmit(&huart3, &c, 1, 100);
            last_c_time = current_time;
        }

        /* 2. Ekranda Yanıp Sönen Yazı (Görsel Efekt) */
        if (current_time - last_blink_time > 500) {
            if (blink_state) printf("\rDosya Bekleniyor...   "); 
            else             printf("\rDosya Bekleniyor      ");
            fflush(stdout);
            blink_state = !blink_state;
            last_blink_time = current_time;
        }

        /* 3. Veri Geldi mi? (Non-blocking) */
        if (HAL_UART_Receive(&huart3, &status, 1, 1) == HAL_OK) 
        {
            if (status == 'e' || status == 'E') { // Çıkış İsteği
                printf("\r\n[IPTAL] Kullanici iptal etti.\r\n");
                return;
            }
            if (status == SOH) { // Paket Başı
                handshake_done = 1;
                printf("\r\n" CLR_GREEN "Transfer Basladi!" CLR_RESET "\r\n");
            }
        }
    }

    /* --- PAKET DÖNGÜSÜ --- */
    while (!xmodem_done) 
    {
        rx_buffer[0] = status; // İlk byte elde
        
        // Kalan 132 byte'ı oku
        if (HAL_UART_Receive(&huart3, &rx_buffer[1], 132, 2000) != HAL_OK) {
            uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
            HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY); continue;
        }
        
        // CRC Kontrol
        uint16_t rcrc = (rx_buffer[131] << 8) | rx_buffer[132];
        if (rcrc != Calc_CRC16_Hex(&rx_buffer[3], 128)) {
             uint8_t n = NAK; HAL_UART_Transmit(&huart3, &n, 1, 100);
             HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY); continue;
        }

        /* --- CANLI İLERLEME (PROGRESS BAR) --- */
        total_bytes += 128;
        // \r ile satır başına dönüp üstüne yazıyoruz
        printf("\r[YUKLENIYOR] Paket: %3d | Toplam: %lu Bytes", packet_number, total_bytes);
        fflush(stdout);

        /* --- HEX PARSING --- */
        if (!hex_parsing_done)
        {
            for (int i = 0; i < 128; i++) 
            {
                char c = rx_buffer[3 + i]; 
                if (c == 0x1A) continue;
                if (c == ':') { in_line = 1; line_idx = 0; continue; }

                if (in_line) 
                {
                    if (c == '\r' || c == '\n') { 
                        in_line = 0;
                        line_buffer[line_idx] = '\0';
                        
                        uint8_t byte_count = ParseByte(&line_buffer[0]);
                        uint16_t addr_low  = (ParseByte(&line_buffer[2]) << 8) | ParseByte(&line_buffer[4]);
                        uint8_t rec_type   = ParseByte(&line_buffer[6]);
                        
                        if (rec_type == 0x00) { // DATA
                            uint32_t current_addr = (hex_upper_addr << 16) | addr_low;
                            
                            // GUVENLIK KONTROLU VE ILK SILME
                            if (is_flash_erased == 0) {
                                uint8_t check = Check_Hex_Address_Range(current_addr, target_slot);
                                if (check == 0 || check == 2) {
                                    // HATA DURUMU
                                    uint8_t can = CAN;
                                    for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 10);
                                    printf("\r\n\r\n[HATA] Adres Uyusmazligi! Dosya: 0x%08lX\r\n", current_addr);
                                    return; 
                                } else {
                                    // ADRES DOGRU -> SIL
                                    if (Bootloader_Flash_Erase_Target_Slot(target_slot) == 0) {
                                        uint8_t can = CAN;
                                        for(int k=0; k<5; k++) HAL_UART_Transmit(&huart3, &can, 1, 10);
                                        printf("\r\n[HATA] Silme Hatasi!\r\n");
                                        return;
                                    }
                                    is_flash_erased = 1;
                                }
                            }
                            
                            // YAZMA
                            if (is_flash_erased == 1) {
                                for(int k=0; k<byte_count; k++) {
                                    uint8_t val = ParseByte(&line_buffer[8 + (k*2)]);
                                    Smart_Hex_Write_Byte(current_addr + k, val); // Yardımcı fonk çağrısı
                                }
                            }
                        }
                        else if (rec_type == 0x01) { // EOF
                            Flush_Smart_Buffer(); // Kalanları yaz
                            hex_parsing_done = 1; 
                        }
                        else if (rec_type == 0x04) { // EXT ADDR
                            uint8_t d1 = ParseByte(&line_buffer[8]);
                            uint8_t d2 = ParseByte(&line_buffer[10]);
                            hex_upper_addr = (d1 << 8) | d2;
                        }
                    }
                    else {
                        if (line_idx < 127) line_buffer[line_idx++] = c;
                    }
                }
            }
        }

        uint8_t ack = ACK;
        HAL_UART_Transmit(&huart3, &ack, 1, 100);
        packet_number++;

        HAL_UART_Receive(&huart3, &status, 1, HAL_MAX_DELAY);
        if (status == EOT) {
            HAL_UART_Transmit(&huart3, &ack, 1, 100);
            // Son kalanları yaz ve aktif slotu güncelle
            Flush_Smart_Buffer(); 
            if (target_slot == SLOT_B_ADDR) Set_Active_Slot(SLOT_B_ACTIVE);
            else Set_Active_Slot(SLOT_A_ACTIVE);
            
            xmodem_done = 1;
        }
    }
    printf("\r\n\n" CLR_GREEN "[OK] HEX Yukleme Tamamlandi!" CLR_RESET "\r\n");
}
